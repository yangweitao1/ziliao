第一部
学习笔记:
day01:


1.shift+鼠标右键  进入cmd,在当前目录下.
2.注释:不会编译和运行,是无效的代码.单行注释//  多行注释/*    */
3.关键字:都是小写的,Java赋予特殊含义的单词,不能用来起名字.
4.标识符:用来起名字的规则.
	1)命名规则:
	(1)标识符可以包含字母,数字,美元符号,下划线(中文也可以用但是不推荐)
	(2)标识符不能以数字开头
	(3)标识符不能是关键字
	2)命名规范:
	(1)类名规范:首字母大写,后面的每个单词首字母大写(大驼峰式)
	(2)方法名规范:首字母小写,后面的每个单词首字母大写(小驼峰式)
	(3)变量名规范:首字母小写,后面的每个单词首字母大写(小驼峰式)
5.常量:java程序中固定不变的数据.
分类:整数常量 小数常量  字符常量  字符串常量  布尔常量  空常量(null none)
6.变量:java中要求一个变量每次只能保存一个数据,必须要明确保存的数据的类型.
7.数据类型:数据类型其实就是变量内存块的大小.
	java数据类型分为两大类:
	基本数据类型:包括整数, 小数(浮点数), 字符, 布尔
	引用数据类型:包括类, 数组,接口等
8.基本数据类型:
字节型(byte) 一个字节  -128到127
短整型(short) 两个字节 -32768到32767
整型(int)     四个字节  21世纪
长整型(long)  八个字节  -2^63到2^63-1
双精度浮点数(double) 八个字节  
单精度浮点数(float)  四个字节
字符型(char)  两个字节  0-65535
布尔型(boolean) 没有指定
9.单精度和长整型 必须加F和L,大小写都可以,建议大写.巧记:服了的;双精度D可以加也可以不加.
10.变量名称:在同一个大括号内,变量的名字不可以相同.
变量赋值:定义的变量,不赋值不能使用(使用变量,是指通过变量名得到变量值(数据)).



day02:

1.数据溢出:强制类型转换,编译不报错后,数据溢出情况:最大值加1变最小值,最小值减1变最大值.
2.+字符串连接,结果为字符串
System.out.println(5+6+"")->11 
System.out.println(""+5+6+)->56
System.out.println(""+(5+6))->11
3.byte,short,char-->int-->long-->float-->double//数据类型从小到大的排序,整数和小数中间插入char,大的变小的强制(小的类型),小的变大(系统自动隐式,类型提升),byte,short,char运算时直接提升为int.
4.++ --独立运算,前后结果一样
 ++ --混合运算,++在前先自增再运算,++在后先运算再自增
5.优先级:() [] 扩或  + - 正负  ++ -- ! 自增自减取反  * / %    + - 运算符  << >> >>>  > < >= <=   == !位移 = 比较运算(关系运算符) $^|按位与或非  && || 逻辑运算符  ?: 三目运算符 = += -= *= /= %= 赋值
6.三元运算符格式: 数据类型 变量名 = 布尔类型表达式？结果1：结果2
7.ASCII码表:int-char  '0'-48 'A'-65 'a'=97 

day03:


1.switch: switch后面常量和变量都可以,变量类型为byte short char int 1.5枚举和1.7String.(不能为小数和long)
		case后面是常量,并且常量不能相同.
		default可以省略.位置也可以变化.
		无break,case向下穿透,直到遇见break或者右括号.
2.if:else可以省略.三种格式.一对一,多对多;二选一,多选一


day04:


重载:
同一个类中,多个方法,方法名相同,形参个数和类型不同的情况属于方法重载.
作用:相同的方法名.表示不同的功能.

方法调用:
(1)直接调用
(2)赋值调用
(3)输出语句调用(sout)

方法注意事项三贱客:
(1)方法定义在类中方法外
(2)return类型和返回值类型匹配,最好一致.
(3)return后面不能再有代码,后面属于无效代码.


day05:
数组概念:数组是存储数据长度固定的容器,并且要求多个数据的数据类型要一致.
数组三种方式以及特点:
方式一: int[] arr = new int[3]  动态初始化:用户给定长度,系统分配数值
方式二: int[] arr1 = new int[]{1,2,3}  静态初始化:用户给数值,系统分配长度
方式三: int[] arr2 = {4,5,6} 快速初始化:不能分开写.因为分开后{}是代码块,非数组


JVM内存划分:
寄存器  给CPU使用,和我们开发无关
本地方法栈  JVM在使用操作系统功能的时候使用,和我们无关
方法区  存储可以运行的class文件
堆内存(辅助内存)  存储对象或者数据,new来创建的都存储在堆内存
方法栈(主要内存)  方法运行时使用的内存,比如main方法运行,进入方法栈中执行

冒泡排序:相邻元素找最大值,并交换位置.
最大值:假设第一个最大法.

数组名作为参数传递的是地址值,作为返回值也是传递的地址值.





day06:
1.成员变量的默认值:

      	        数据类型                   	默认值     
  基本类型	整数（byte，short，int，long）	0       
      	        浮点数（float，double）      	0.0     
      	        字符（char）               	'\u0000'
      	        布尔（boolean）            	false   
  引用类型	数组，类，接口                	null    

2.成员变量和局部变量的区别:
.- 在类中的位置不同 重点 
  - 成员变量：类中{}，方法外
  - 局部变量：方法中{}或者方法声明()上(形式参数)
- 作用范围不一样 重点 
  - 成员变量：类中
  - 局部变量：方法中
- 初始化值的不同 重点 
  - 成员变量：有默认值
  - 局部变量：没有默认值。必须先定义，赋值，最后使用(使用变量,通过变量名得到变量的值)
- 在内存中的位置不同 了解 
  - 成员变量：堆内存,属于对象,dui,堆内存
  - 局部变量：栈内存,暂时,栈内存
- 生命周期不同 了解 
  - 成员变量：随着对象的创建而存在，随着对象的消失而消失
  - 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失

3.
  1). 如果你不提供构造方法，系统会给出无参数构造方法。
  2). 如果你提供了构造方法，系统将不再提供无参数构造方法。
  3). 构造方法是可以重载的，既可以定义参数，也可以不定义参数。

4.private的含义
	1). private是一个权限修饰符，代表最小权限。
	2). 可以修饰成员变量和成员方法。
	3). 被private修饰后的成员变量和成员方法，只在本类中才能访问。
5.封装:
	隐藏对象的属性和实现细节(方法),对外提供公有的访问方式,方法由我提供的,别人不能乱修改,提高代码的安全性
6.基本数据类型存的是值.引用数据类型存的是地址值,就是new出来的东西,在堆内存,有地址值.

7.this:记住 ：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。
8.构造方法的特点:方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void,但是可以return;结束构造方法回到main方法的出口结束程序//记忆




day07:


1.bug:
Scanner类,nextInt和nextLine方法,调用的时候,enter键在第二个方法时候会直接为空结束.调整顺序或者方法,或者创建新对象调用可以避免.
2.
ArrayList对象不能存储基本类型，只能存储引用类型的数据
基本类型

基本类型对应的包装类(引用数据类型)

byte
Byte

short
Short

int
Integer

long
Long

double
Double

float
Float

char
Character

boolean
Boolean

方法:
equals
contains






day08:
1.字符串:字符串常量一旦创建不可改变,常量池里二次创建可以被共享,底层其实是字符数组.
- - java.lang.String ：此类不需要导包
- 常见构造方法
  - public String() ：通过无参构造方法创建一个空字符串对象,结果跟""是一样的意思String s = "";
  - public String(char[] value) ：通过构造方法传入字符数组,把字符数组变成字符串对象
  - public String(byte[] bytes) ：通过构造方法传入字节数组,把字节数组变成字符串对象
  - 总结,通过String类的无参构造方法String(),往()塞入字节数组,字符数组,字符串常量,给对象内存块装上
2.
判断功能:判断字符串的内容值是否相等,有区分大小写和忽略大小写两方法
- public boolean equals (Object anObject) ：判断调用方法的字符串,跟传入方法的字符串对象内容是否相等,在严格区分大小写的情况下,内容相等返回true,否则返回false
- public boolean equalsIgnoreCase (String anotherString) ：判断调用方法的字符串,跟传入方法的字符串对象内容是否相等,在忽略大小写的情况下,内容相等返回true,否则返回false

3.
获取功能:底层是字符数组,可获取索引,字符,字符个数,拼接变长,截取变短
- public int length () ：得到调用方法的字符串的长度,字符串由字符构成,即得到字符串里面字符的个数
- public String concat (String str) ：把调用方法的字符串跟传入方法的字符串,串成一个新的字符串,+
- public char charAt (int index) ：得到调用方法的字符串,传入的索引对应的字符,比如传入0索引得到第一个字符,其他以此类推
- public int indexOf (String str) ：得到传入方法的字符串,第一次出现在调用方法的字符串的位置的索引,找不到返回-1表示
- public int lastIndexOf(String str) ：得到传入方法的字符串,最后一次出现在调用方法的字符串的位置的索引,找不到返回-1表示
- public String substring (int beginIndex) ：截取字符串,从调用方法的字符串传入的开始索引一直截取到末尾,截取,从哪里开始到哪里结束,只告诉我开始索引,没有告诉我结束索引,那默认就截取到字符串的末尾
- public String substring (int beginIndex, int endIndex) ：截取字符串,从开始索引截取到结束索引-1的那一段,即含头不含尾,或者巧记为神龙见首不见尾

4.
转换功能:转换成字符数组,字节数组,替换所有

- public char[] toCharArray () ：把调用方法的字符串转换成字符数组 
- public byte[] getBytes () ：把调用方法的字符串转换成字节数组
- public String replace (CharSequence target, CharSequence replacement) ：替换调用方法的字符串,用后面的东西替换字符串里面出现的前面的东西,默认替换所有,
即replace sth with sth;产生新的字符串,原来的字符串没有改变,所以要定义一个新的变量接收方法的结果,CharSequence 字符序列,字符串也是字符序列

5.
切割功能:按照什么来切割得到一个字符串数组,遍历数组得到切割后的东西
- public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分(切割)为字符串数组

6.
静态代码块static {},在类中方法外,写个static修饰的代码块
- 静态代码块：定义在成员位置，即类中方法外,使用static修饰的代码块{ }。
  - 位置：类中方法外。
  - 执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。//执行特点,需要记忆!!!
7.
java.util.Arrays  此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。
 操作数组的方法
- public static String toString(int[] a) ：返回指定数组内容的字符串表示形式。
- public static void sort(int[] a) ：对指定的 int 型数组按数字升序进行排序。
8.==引用数据类型比较的是地址值,基本数据类型比较的才是值.
9.static关键字,静态共享的意思,用其修饰的东西属于类,随着类的加载而加载(字节码一个一次),优先于对象存在,给类的所有对象共享,所以除了类名.还可以使用对象名.来调用(使用拿到)//记忆
10.静态方法调用的注意事项：//巧记,静态访问静态,非静态啥都可以,静态没有this

- 静态方法可以直接访问类变量和静态方法。//静态访问静态,非静态啥都可以
- 静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。
- 静态方法中，不能使用this关键字。





day09:
1.定义//记忆

- 继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性(成员变量)和行为(成员方法)。

2.好处//记忆

1). 提高代码的复用性(少写了很多代码实现一样的功能)
2). 类与类之间产生了关系，是多态的前提

弊端:类的耦合性加强了//面试可能问,建议记忆一下

	开发中的原则:高内聚,低耦合,一般的,如果一个类能自己干的,就不要跟其他类发生过多的关系

	内聚:就是类自己独立完成某件事情的能力

	耦合:就是类与类之间的关系(万一其中一个类写坏了,其他类也坏了)
3.继承后的特点——成员变量,就近原则,子类有就使用子类的,否则使用父类的//记忆
4.继承后的特点——成员方法,就近原则,子类有就使用子类的,否则使用父类的//记忆
5.方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写(能够继承拿到然后在子类重写一遍)//记忆
6.注意事项//记忆
	1). 子类重写方法的访问权限要大于或者等于父类(子类要比父类更加强大,强大到访问权限都比父类强大,不能比父类弱)					
	2). 子类方法覆盖父类方法，返回值类型(子父类关系,要求子类的返回值是父类返回值的子类)、函数名和参数列表都要一模一样。
7.private(私有仅仅在本类中被访问)-默认什么都不写(默认可以在同一个包下被访问,巧记默认同胞)
  protected(受保护的,只能给子类去访问不管是否同包)-public(公有在哪里都可以访问,公有秒杀)

8.
1. 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。
2. 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用

9.- super ：代表父类的存储空间标识(可以理解为父类的引用,实际是个内存块)

- this ：代表当前对象的引用(谁调用就代表谁,存储的是地址值)

super和this的用法//记忆

10.
继承后类与类之间的关系与特点//记忆,(能够说出继承的特点,或者说注意事项!),(java中的继承只支持单继承(即一个类只能有一个父类一个孩子只能有一个亲爹),但是可以多层继承(子继承父父继承爷就相当于孙子间接继承了爷爷)

11.
1. 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。
   理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体{}，做不了事情,没有意义。
2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。
   理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。
3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
   理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。
4. 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 
   理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。



day10:
1.接口没有静态代码块static{},没有构造方法,不能定义成员变量,都是常量.public static final  类型 x.(不写系统写)是类都有构造方法,包括抽象类.
2.多态:继承 方法重写 父类引用指向子类对象.非静态方法,其他都不能多态.
3.
含有抽象方法,//跟抽象类里面的抽象方法用法一致,JDK1.7以前

抽象方法：使用abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。

含有默认方法和静态方法//JDK1.8含以后

默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。

静态方法：使用 static 修饰，供接口名点来直接调用,注意这里不可以给干儿子类调用!!!


含有私有方法和私有静态方法//1.9为上面的默认方法和静态方法服务的

私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用。
4.接口名.常量 和 接口名.静态方法名
5.
一个类只能继承(亲生血缘关系)一个父类(亲爹)。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。省略default
接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次

6.一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。不能省略default
7.前提【重点】

1). 继承或者实现【二选一】
2). 方法的重写【意义体现：不重写，无意义】
3). 父类引用指向子类对象【格式体现】//引用:引用数据类型的变量就叫引用f,Fu f = new Zi();//()


8.多态时,缺少父类方法报错,缺少子类方法无报错但是没意义.
9.多态的好处，体现在，可以使程序编写的更简单，并有良好的复用性,扩展性,维护性。
10.
向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。
向下转型,目的是为了,调用子类特有的变量和方法.一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。

11. 多态://就记这句话多态就懂就会用了!!!
		 当父类引用指向子类对象的时候,用父类引用调用非静态方法编译看左边父类,运行的结果看右边子类,其他情况不管编译运行都看左边父类



day11:
1.{}构造代码块,在构造方法前执行.
2.final修饰引用数据类型,默认值无效.只能赋值一次.
3.final可以修饰类,成员变量,方法.修饰类不能被继承,修饰方法不能被重写,修饰变量只能赋值一次,不能修改.
4.外部类不能加static.
5.成员内部类和局部内部类.成员内部类当做成员变量. 外部类.内部类 对象名=new 外部类().new 内部类().
6.局部变量不能用权限修饰符.
7.匿名内部类是局部内部类的一种.



=====================================================================================就业班================================================================================================

day01:

1.Object:对象类java.lang.Object类是所有类的父类(又叫根类,超类,基类),它里面写了所有子类应该具有的共同功能,为了让所有类都可以使用这些共同功能,所有类都直接或者间接的继承Object类(能够说出Object类的特点)
	对象,也是一类事物,所以写对象类来模拟,对象在堆内存中创建看不见也摸不着,所以提供toString方法把对象变成带有地址值的字符串. 并提供equals方法比较对象的地址值是否相等,这两个方法子类可以继承,也可以重写做自己想要做的事情,重写都可以用idea的alt insert自动生成,由于万物皆对象,所以所有的类都具有上面的方法,Object类是所有类的父类,所有类都直接或者间接的继承Object类
2.都是地址值.比较内容值需要重写两个方法,alt+insert
toString()
equals()
3.
字符串重写了equals方法,所以比较的是内容值.直接调用的.
4.Date也重写了toString方法.

5.Date类,总结:日期类,模拟日期形式的时间,可以调用getTime方法精确到毫秒,得到日期时间的时间毫秒值,其构造方法,无参数表示当前时间,有参数就有参照物时间加上方法传入时间,参照物时间为1970年1月1日0时0分0秒,中国要加多8个小时!
6.DateFormat类,日期格式化,把日期格式化为指定的字符串,由于它是抽象类,所以用的是它的子类SimpleDateFormat,通过构造方法传入格式,拿到对象名调用format方法把Date对象格式化为字符串,反过来就是解析,调用的是parse方法,巧记简单,simple
7.java.util.Calendar是日历抽象类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性,年,月,日等。
 1)创建子类对象,通过日历类的静态方法getInstance,即得到对象方法获取
 2)根据Calendar类的API文档，常用方法有：

- public int get(int field)：返回给定日历字段的值。字段,指的是年,月,日,等
- public void set(int field, int value)：将给定的日历字段设置为给定值。
- public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。
- public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。

Calendar类中提供很多成员常量，代表给定的日历字段：

  字段值         	含义                  
  YEAR        	年                   
  DAY_OF_MONTH	月中的天（几号）            
  HOUR        	时（12小时制）            
  HOUR_OF_DAY 	时（24小时制）            
  MINUTE      	分                   
  MONTH       	月（从0开始，可以+1使用）      
  SECOND      	秒                   
  DAY_OF_WEEK 	周中的天（周几，周日为1，可以-1使用）

8.
java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：

- public static long currentTimeMillis()：返回以毫秒为单位的当前时间。
- public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。

9.StringBuilder/StringBuffer是个字符串的缓冲区(暂时存放数据的地方)，即它是一个容器，容器中可以装很多字符串。内部拥有一个数组用来存放字符串内容，进行字符串拼接时，
	直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)
 1)构造方法

根据StringBuilder的API文档，常用构造方法有2个：

- public StringBuilder()：构造一个空的StringBuilder容器。
- public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。
 2)StringBuilder常用的方法有3个：

- public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。
- public String toString()：将当前StringBuilder对象转换为String对象。
- public StringBuilder reverse()：将当前StringBuilder对象里面的内容进行反转,如abc反转后变成cba

10.包装类:
自动装箱与自动拆箱,基本数据类型和其对应的引用数据类型互相转换,系统自动完成,jdk1.5开始支持,把基本数据类型自动变成其对应的引用数据类型叫做自动装箱,反过来就是自动拆箱!!!!!
除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：

- public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型,Byte类里面的方法
- public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。//Short类静态
- public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。//Integer.p("3")=3;
- public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。
- public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。
- public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。
- public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。

11.类和接口前面只能用public修饰或者无,不能用protected private default
12.protected只适合于子类对象,调用父类成员变量和成员方法时候,不同包之间的调用.


day02:
1.
- 集合和数组既然都是容器，它们有啥区别呢？(能够说出集合与数组的区别:)
- 数组的长度是固定的。集合的长度是可变的。
- 数组中可以存储基本数据类型的值,也可以用来存储对象
  集合存储的都是对象,而且对象的类型可以不一致。一般开发中,当对象多的时候，推荐使用集合进行存储。
2.
集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map
llection：单列集合类的根接口，用于存储一系列符合某种规则(抽象方法)的元素，

它有两个重要的子接口，分别是java.util.List和java.util.Set。

List的特点是元素有序、元素可重复,有索引。相反的是,Set的特点是元素无序，而且不可重复,无索引。

List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。

3.
Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，(这些方法可用于操作所有的单列集合。
	说出Collection集合的常用功能,从增删改查的角度去出发想象即可)方法如下：

- public boolean add(E e)：  把给定的对象添加到当前集合中 。//增
- public boolean remove(E e): 把给定的对象在当前集合中删除。//删一个
- public void clear() :清空集合中所有的元素。//删除所有
- public Object[] toArray(): 把集合中的元素，存储到数组中。//改,变成数组,转换成数组
- public boolean contains(E e): 判断当前集合中是否包含给定的对象。//查,是否包含元素,针对的是一个
- public boolean isEmpty(): 判断当前集合是否为空。//查,是否没有元素,针对的是所有情况
- public int size(): 返回集合中元素的个数。//查,元素的个数,针对的也是所有情况

4.
Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。
迭代器原理内置了一个指针,一开始在集合的外面,每调用一次next方法,指针向下移动一次,得到对应的元素

5.增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。
对于集合来说其实是个Iterator迭代器，所以在遍历的过程中，不要对集合中的元素进行增删操作.
增强for循环遍历数组底层是个普通for循环不是迭代器,集合底层才是!!!.

6.
tips: 增强for循环必须有被遍历的目标。目标只能是Collection单列集合或者是数组。
新式for仅仅作为遍历操作出现,不要在里面进行增删操作!!!否则有时候会出现问题并发修改异常,所有应该避免这样做!!!
如果我一定要这么做,怎么解决:很简单,把ArrayList换成CopyOnWriterArrayList

7.- 泛型：可以在类或方法中预先地使用未知的类型。

tips:一般在创建对象时，才将未知的类型确定为具体的类型。当没有指定泛型时，默认类型为Object类型。

8.
tips:泛型也是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。
9.
泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。


10.
具体类型要求泛型前后是一致的,?右边的具体类型都可以接收匹配!!!
泛型的通配符<?>:不知道使用什么类型来接收泛型的时候,此时可以使用?来表示未知通配符。

此时只能接收数据,不能往集合中存储数据。

11.
泛型的上限：

- 格式： 类型名称 <? extends 类 > 对象名称
- 意义： 只能接收该类型及其子类

泛型的下限：

- 格式： 类型名称 <? super 类 > 对象名称
- 意义： 只能接收该类型及其父类型


day03:
1.
List特有方法，如下：//巧记,跟索引相关的增删改查,其中增加方法是插入方法
- public void add(int index, E element): 插入,添加,将指定的元素，添加到该集合中的指定位置上。可以在头部或者尾部插入,索引不报异常,其他都报索引越界异常!!!//增,插入增加
- public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。//删,间接删
- public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回更新前的元素。//改,设置
- public E get(int index):返回集合中指定位置的元素。//查,得到元素,根据索引得到元素
  List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：
2.
LinkedList集合数据存储的结构是链表结构(双向链表)。方便元素添加、删除的集合。
- public void addFirst(E e):将指定元素插入此列表的开头。//增,头和尾
- public void addLast(E e):将指定元素添加到此列表的结尾。
- public E removeFirst():移除并返回此列表的第一个元素。//删,头和尾
- public E removeLast():移除并返回此列表的最后一个元素。
- public E getFirst():返回此列表的第一个元素。//查,头和尾
- public E getLast():返回此列表的最后一个元素。
- public boolean isEmpty()：如果列表不包含元素，则返回true。//查,是否为空
- public E pop():从此列表所表示的堆栈处弹出一个元素。底层就是removeFirst方法
- public void push(E e):将元素推入此列表所表示的堆栈。底层就是addFirst方法

3.
- java.utils.Collections是集合工具类，操作的对象是集合。部分方法使用如下：
- public static <T> boolean addAll(Collection<T> c, T... elements):往传入集合中添加一些元素。
- public static void shuffle(List<?> list):随机置换,即可以打乱集合顺序。
- public static <T> void sort(List<T> list):将集合中元素按照默认规则排序,整数从小到大排序
- public static <T> void sort(List<T> list，Comparator<? super T> c):将集合中元素按照指定规则排序。
4.
Comparable：强行对实现它的每个类的对象,进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。
		只能在类中实现compareTo()一次，不能经常修改类的代码,实现自己想要的排序。实现此接口的对象（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，
		对象可以用作有序映射中的键,或有序集合中的元素，无需指定比较器。//记忆,类内部实现比较器,默认规则

Comparator:也强行对某个对象,进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。
		还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象提供排序。//记忆,外比较器,类的外部自己写规则

//记忆,不管是内比较器还是外比较器,只要排序都要实现这两个接口之一,

如果两个接口都实现,优先考虑的外比较器Comparator
4.
List接口特点：(能够说出List集合特点,有序,有索引,可以存储重复元素)
5.
Set接口
Set集合有多个子类，这里我们介绍其中的java.util.HashSet、java.util.LinkedHashSet这两个集合。
tips:Set也是单列集合,取出元素的方式可以采用：迭代器、增强for(对于集合底层也是迭代器)。

6.
数据存储的常用结构有：栈、队列、数组、链表和红黑树。
栈:先进后出,出口入口都在栈的顶端位置.
- 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。
- 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置.
队列：queue,简称队，先进后出,出口和入口各占一侧.它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。
数组//特点:查找快因为有索引,查找元素快,增删慢,因为数组的长度的是固定死了的,要增删要创建一个新的数组,然后给数组拷贝元素,消耗时间,相对慢
链表//特点跟数组刚好相反,Node接口,节点.- 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素- 增删元素快：//new Node();- 增加元素：只需要修改连接下个元素的地址即可。
红黑树:红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。我们只要红黑树是为了提高搜索效率的就行了

7.HashSet集合介绍//特点:无索引,无序,去重,跟List集合相反
HashSet去重原理图解:底层是哈希表存储元素去重,用的是hashcode和equals方法
在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理哈希冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，
	即hash值相等的元素较多时，通过key值依次查找的效率较低。
而在JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

8.在HashSet下面有一个子类java.util.LinkedHashSet,LinkedHashSet它是链表和哈希表组合的一个数据存储结构,比HashSet不同,是有序.

--(LinkedList集合数据存储的结构是链表结构(双向链表))

9.
可变参数,本质是一个数组,表示0个或者多个参数,写在最后.
修饰符 返回值类型 方法名(参数类型... 形参名){  }//int...a//可变参数,本质是一个数组.其实这个书写完全等价与
修饰符 返回值类型 方法名(参数类型[] 形参名){  }//int[] a

10.工具集合类排序:
想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则.
如:Collections.sort(al,new Comparator<Student>(){})
只能在类中实现compareTo()一次，不能经常修改类的代码,实现自己想要的排序。实现此接口的对象（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，
对象可以用作有序映射中的键,或有序集合中的元素，无需指定比较器。
如:类中实现Comparable<Student>,方法调用Collections.sort(al).


day04:
1.
Map双列集合//Map集合是双列集合存一对对数据,特点是无序,通过键找到值,要求键是唯一的(能够说出Map集合特点)
2.
- Collection中的集合称为单列集合，Map中的集合称为双列集合。
- 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。
3.
MAP常用子类:
- HashMap<K,V>：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。(这也是昨天HashSet的底层去重原理)
- LinkedHashMap<K,V>：HashMap下有个子类LinkedHashMap，存储数据采用了哈希表结构+链表结构。
			通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。
4.
tips：Map接口中的集合都有两个泛型变量<K,V>,在使用时，要为两个泛型变量赋值数据类型。两个泛型变量<K,V>的数据类型可以相同，也可以不同。//kv,只能引用数据类型,泛型要求
5.
Map接口中定义了很多方法，常用的如下：//双列集合,常用方法无非增删改查!!!

- public V put(K key, V value):  把指定的键与指定的值添加到Map集合中。//增也是它,改也是它,键唯一,值覆盖,有覆盖就返回被覆盖的旧的值,没有覆盖返回null表示
- public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。
- public V get(Object key) 根据指定的键，在Map集合中获取对应的值。如果没有键,没有值,绑定,返回null表示
- public Set<K> keySet(): 获取Map集合中所有的键，存储到Set集合中。即键的集合
- public Set<Map.Entry<K,V>> entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。即键值对类的对象的集合,存的是每一个键值对对象,模拟键值对,
					得到每一个键和每一个值的方法,键值对类里面写了,模拟键值对,由键和值组成,自然可以得到键和得到值的方法
6.
tips:

使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； (增删改查其实没有的时候都返回null)

若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的旧值），并把指定键所对应的值，替换成指定的新值。
7.

在Map集合中也提供了获取所有Entry键值对对象的方法：
- public Set<Map.Entry<K,V>> entrySet(): 键值对对象的集合,获取到Map集合中所有的键值对对象的集合(Set集合)。
既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：
- public K getKey()：获取Entry对象中的键。
- public V getValue()：获取Entry对象中的值。

8.
HashMap存储自定义类型的键,键要求是唯一的,键去重跟HashSet的处理重写方法是一样的(即能够使用HashMap存储自定义键值对的数据,在子类按alt insert重写hashCode和equals)

9.
 Java 9，添加了几种集合方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态of方法可以更方便地创建集合的不可变实例(添加数据集合后,不能改变,即不能增删改元素,得到元素遍历元素可以,例如不能再调用add,put方法添加数据)
 1):of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；
 2):返回的集合是不可变的；生出来固定死了,不能添删或者改变元素,但是遍历得到元素可以



day05:
1.
异常 ：指的是程序在执行( 编译和运行)过程中，出现的非正常的情况，最终会导致JVM的非正常停止(中断)。
产生异常就是创建异常对象并抛出了一个异常对象。Java虚拟机默认处理异常的方式是中断处理,把程序中断,停止,并告诉你异常问题的名字,原因,代码位置!!!
2.
异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。
3.
Throwable中的常用方法：//留

- public void printStackTrace():打印异常的详细信息。
  包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,可以使用printStackTrace。
- public String getMessage():获取发生异常的原因。
  提示给用户的时候,就提示错误原因。
- public String toString():获取异常的类型和异常描述信息(手动写一般不用)。

4.
- 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)
- 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)

5.
声明异常throws,throw产生一个真实具体的问题,throws问题的处理方式,不负责任处理,交给jvm,中断,问题类型,原因,位置

6.
 捕获异常try…catch,不是throws踢皮球不负责的处理,而是自己能处理,自己处理,既然是自己处理,没有交个jvm,所以没有中断,后续代码继续执行!!!
 (throws踢皮球方式最终交个jvm中断,后续代码不再执行!!!)

7.
 finally 代码块,跟try或者trycatch组合用的,不能单独使用,最终的,里面的代码永远都会执行,除非你在它之前退出Java虚拟机,用这行代码,System.exit(0);,程序立马停止,后面的代码不走

 8.
 - 运行时异常被抛出(throw异常对象)可以不处理。即不捕获(trycatch)也不声明(throws)抛出。
- 如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。//
- 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出//
- 当多异常处理时，捕获处理，前边的类不能是后边类的父类
- 在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收(一定要做事情)。
- 如果finally有return语句,永远返回finally中的结果,避免该情况. //

9.
自定义异常//就是自己写的异常(一类事物类,希望成为异常的一种,继承,谁是谁的一种,做法继承异常类,并且调用父类有参构造方法传入异常信息,在需要的用到的地方抛出子类对象即可)//记忆!
10.
异常类如何定义:

1. 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。
2. 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。

day06:
1.
每一个执行线程都有一片独立自己所属的栈内存空间
2.
多线程,特点,随机性,单核cpu并发一会执行这个线程,一会执行另外一个线程,造成代码随机性的现象,可做多个事情!!!
注意事项:子线程的名字,第一个名字Thread-0,第二个...1,其他
3.
构造方法：//创建对象,给Thread类里面成员变量字符数组进行赋值,线程的名字只是把这个字符数组变成字符串

                   //注意jdk1.9直接把字符串数组变成了字符串

- public Thread():分配一个新的线程对象。默认名字第一个子线程叫Thread-0,其他以此类推//super();
- public Thread(String name):分配一个指定名字的新的线程对象。//super(name);
- public Thread(Runnable target):分配一个带有指定目标任务的,新的线程对象,默认名字第一个子线程叫Thread-0,其他以此类推
- public Thread(Runnable target,String name):分配一个带有指定目标任务的,新的线程对象,并指定线程的名字。
4.常用方法:
非静态方法,只能通过对象名.来调用:

- public String getName():获取当前线程的名字
- public String setName():设置当前线程的名字
- public void start():导致此线程开始执行; Java虚拟机调用此线程的run方法。同一个线程对象不能多次调用start方法,否则会报非法线程状态异常:IllegalThreadStateException
- public void run():此线程要执行的任务,在此处定义代码(写代码做事情)。

静态方法,除了类名.来调用,还能通过对象名.来调用:

- public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。
- public static Thread currentThread():返回当前正在执行的线程对象的引用,引用即Thread线程的对象名

翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，

5.
采用java.lang.Runnable也是非常常见的一种，我们只需要重写run方法即可。

步骤如下：

1. 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
2. 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
3. 调用线程对象的start()方法来启动线程。

6.
tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法而已。

7.
实现Runnable接口比继承Thread类所具有的优势：//记忆

1. 适合多个相同的程序代码的线程去共享同一个资源。
2. 可以避免java中的单继承的局限性。//
3. 增加程序的健壮性，实现解耦(耦合:类与类之间关系)操作，代码可以被多个线程共享，代码和线程独立。
4. 线程池只能放入实现Runable或Callable接口线程，不能直接放入继承Thread的类。//

扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，
      实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。
8.
匿名内部类,代表一个类或者一个接口的(干)子类对象,简化格式,前提要存在一个类或者一个接口:格式如下:

new 类名或接口名(){

	重写方法,如果是普通类可以写也可以不重写,如果是抽象类或者是接口必须要重写抽象方法

}//这个整体,就代表一个类或者一个接口的子类对象

9.
同步就可以让cpu在某段时间内只让一个线程进来做事情,其他线程不能进来,等你做完了才能一个一个进来(理解为排队一个个来不会有问题),同步技术包括,同步代码块,同步方法,Lock锁//记忆

10.
同步代码块：synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。
1. 锁对象 可以是任意类型。
2. 多个线程对象  要使用同一把锁。

注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED进入阻塞状态)。

11.
同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。
同步锁是谁?
      对于非static方法,同步锁就是this。  
      对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。

12.
java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。

Lock锁也称同步锁，加锁与释放锁方法化了，如下：

- public void lock():加同步锁。
- public void unlock():释放同步锁。
Lock lock = new ReentrantLock();//多态写法,父接口引用指向接口的实现类对象

13.
| 线程状态                | 导致状态发生条件                                             
| ----------------------- | ------------------------------------------------------------
| NEW(新建)               | 线程刚被创建即new出来的时候，但是并未启动。还没调用start方法.
| Runnable(可运行)        | 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器cpu.
| Blocked(锁阻塞)         | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有时，该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable可运行状态。
| Waiting(无限等待)       | 一个线程在等待另一个线程执行一个（唤醒）动作时，调用wait()方法,该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify随机唤醒一个或者notifyAll方法才能够唤醒。 |
| Timed Waiting(计时等待) | 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep (时间参数)、Object.wait(时间参数5000毫秒自动唤醒)。 |
| Teminated(被终止)       | 执行完run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡.

14.
sleep方法的使用还是很简单的。我们需要记住下面几点：

1. 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。//wait(时间)
2. 为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠
3. sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。
小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。








day07:
1.
线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，从而无需反复创建线程而消耗过多资源。
2.
等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：
1). wait：线程不再活动，不再参与调度，进入 wait set(等待集合) 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中
2). notify：则选取所通知对象的 wait set 中的一个线程释放；即随机唤醒其中一个等待的线程
3). notifyAll：则释放所通知对象的 wait set 上的全部线程。
- 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；
- 否则，线程就从 WAITING 状态又变成 BLOCKED 状态
3.
调用wait和notify方法需要注意的细节(把握一个原则,用锁等待,用同一个锁唤醒)
1). wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。
2). wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。
3). wait方法与notify方法必须要在同步代码块或者是同步函数方法中使用。因为：必须要通过锁对象调用这2个方法。

4.
合理利用线程池能够带来三个好处：//记忆,资源,速度,管理
1). 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
2). 提高响应速度。当任务到达时，任务可以不需要等到线程创建,就能立即执行。
3). 提高线程的可管理性。可以根据系统的承受能力，调整线程池中,工作线线程的数目，防止因为消耗过多的内存，
   而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。
5.
线程池的使用,简单,记产生线程池的工具类Executors,然后线程池对象提交任务执行即可
Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。

6.
Executors类中有个创建线程池的静态方法如下：
- public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)
获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：
- public Future<?> submit(Runnable task或者Callable tast):获取线程池中的某一个线程对象，并执行提交的任务
- 上面submit提交方法,如果提交的是Callable接口实现类对象,重写的call方法可以产生返回值,通过Future未来对象的get方法来获取
  Future接口：未来接口,其接口实现类对象,用来记录线程任务执行完毕后产生的结果

使用线程池中线程对象的步骤：
1). 创建线程池对象。
2). 创建Runnable接口子类对象。(task)
3). 提交Runnable接口子类对象。(take task)
4). 关闭线程池(一般不做)。

7.
Lambda表达式,简单记,接口引用调用自己唯一的一个抽象方法时,以前用的是匿名内部类,现在可以用lambda表达式来代替,做的事情无法是:参数传递,执行方法体做事情,()->{}

8.
省略规则

在Lambda标准格式()->{}的基础上，使用省略写法的规则为：//记忆

1). 小括号内参数的类型可以省略；
2). 如果小括号内有且仅有一个参数，则小括号可以省略；
3). 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。

9.
1). 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法(函数式接口)。
   无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。
2). 使用Lambda必须具有上下文推断。
   也就是方法的参数或局部变量类型,必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。
备注：有且仅有一个抽象方法的接口，称为“函数式接口”,这个后面还会学习。


day08:
1.
java.io.File 类是文件和目录(文件夹)路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。

2.构造方法:
- public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。  
- public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。
- public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 
3.常用方法:
- public String getAbsolutePath() ：返回此File的绝对路径名字符串。带有盘符,比如D:\a.png;
- public String getPath() ：返回此File类构造方法传入的路径名字符串。 
- public String getName()  ：返回由此File表示的文件或文件夹的名称。  
- public long length()  ：返回由此File表示的文件的长度,大小,不能获取文件夹的大小 
4.路径:
- 绝对路径：从盘符开始的路径，这是一个完整的路径。如"D:\a.png";
- 相对路径：相对于某个东西而言的路径，这是一个便捷的路径，开发中经常使用。注意idea相对的是工作空间而不是工作空间下写的模块(也就是你在eclipse里面认为的项目),而eclipse相对的才是我们写的项目!!!

5.
判断功能方法:
- public boolean exists() ：此File表示的文件或文件夹路径是否实际存在。
- public boolean isDirectory() ：此File表示的是否为文件夹目录。
- public boolean isFile() ：此File表示的是否为文件。
6.
创建删除功能的方法,不存在就创建,存在不创建

- public boolean createNewFile() ：当且仅当具有该名称的文件不存在时，才创建一个新的空文件。 
- public boolean delete() ：删除文件或文件夹 ,删除不走回收站,直接删除文件夹要求是空文件夹(有,先删里面,再删外面的)
- public boolean mkdir() ：创建单级文件夹,单级,单个文件夹,不管路径多么复杂
- public boolean mkdirs() ：创建多级文件夹,多个文件夹,不管路径是否存在,s复数,多个
7.
高级获取功能,文件夹遍历,调用方法的对象要求是文件夹路径

- 简单,高级获取功能,指的是打开文件夹,要么得到下面东西的名字,要么得到路径,都存到对应数组里面去了
- public String[] list() ：列出,打开调用方法的文件夹,得到下面东西的名字,存到数组里

- public File[] listFiles() ：列出,打开调用方法的文件夹,得到下面东西的File类型的路径,存到数组里
  注意,调用list或者listFiles方法的File对象，表示的必须是实际存在的文件夹，否则返回null，无法进行遍历
8.
递归：指在当前方法内,方法自己调用自己的这种现象,前提是这个方法也要给调用起来
1.递归一定要有一个出口,否则容易出现栈内存溢出错误StackOverflowError

2.递归调用次数不能过多,否则容易出现栈内存溢出错误StackOverflowError

3.构造方法不能递归调用,,否则容易出现栈内存溢出错误StackOverflowError

9.
java.io.FileFilter是一个接口，是File的过滤器。 该接口的对象可以传递给File类的listFiles(FileFilter) 作为参数， 接口中只有一个方法。

boolean accept(File pathname) ：测试pathname是否应该包含在当前File目录中，符合则返回true。


day09:

\r\n flush
new String

1.
流向内存是输入流，流出内存的是输出流
按照数据的流向分为：输入流和输出流。

- 输入流 ：把数据从其他设备上读取到内存中的流。 //功能,读数据
- 输出流 ：把数据从内存 中写出到其他设备上的流。//功能,把数据写到其他地方

按照数据的类型分为：字节流和字符流。

- 字节流 ：以字节为单位，读写数据的流。
- 字符流 ：以字符为单位，读写数据的流。//字符流=字节流+码表

2.
注意:一般情况下,看到类以stream结尾是字节流,以er结尾的是字符流!!!

3.
字节流可以传输任意文件数据

4.
java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能(方法)。

- public void close() ：关闭此输出流,并释放与此流相关联的,任何系统资源。  内置缓冲区刷新
- public void flush() ：刷新此输出流,并强制任何缓冲的输出字节被写出。  
- public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。  
- public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  
- public abstract void write(int b) ：将指定的字节写到输出流。97,码表翻译a,打开文件是a
小贴士：
close方法，当完成流的操作时，推荐调用此方法，来释放系统资源。

5.
OutputStream有很多子类，我们从最简单的一个子类开始。
java.io.FileOutputStream类是文件输出流，把数据写出到文件中。
构造方法
- public FileOutputStream(File file)：创建文件输出流,以写入由指定的 File对象表示的文件。 
- public FileOutputStream(String name)： 创建文件输出流,以指定的名称写入文件。  
当你创建一个输出流对象写数据到文件中时，必须传入一个文件路径。输出流的构造方法，如果没有这个文件，会创建该文件。
如果有这个文件，会清空这个文件的数据(不想清空,在构造方法()里面加个逗号和true表示追加内容,不清空原来的数据)。

6.
写出字节数据,(能够使用字节输出流写出数据到文件)
1)写出字节：write(int b) 方法，每次可以写出一个字节数据
2)写出字节数组：write(byte[] b)，每次可以写出数组中的数据
3)写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节

7.
数据追加续写
- public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。  
- public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。  
这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了

8.
- 回车符\r和换行符\n ：
  - 回车符：回到一行的开头（return）。
  - 换行符：下一行（newline）。
- 系统中的换行：
  - Windows系统里，每行结尾是 回车+换行 ，即\r\n；
  - Unix系统里，每行结尾只有 换行 ，即\n；
  - Mac系统里，每行结尾是 回车 ，即\r。

9.
java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。
- public void close() ：关闭此输入流,并释放与此流相关联的任何系统资源。    
- public abstract int read()： 从输入流读取数据的下一个字节。 
- public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。
小贴士：
close方法，当完成流的操作时，调用推荐此方法，释放系统资源。

10.
java.io.FileInputStream类是文件输入流，用来读取文件的。
构造方法
- FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 
- FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  
当创建一个输入流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 

11.
超级总结:不会读,记下面的!!!
字节输入流FileInputStream读一个字节read()和读一个字节数组read(byte[] arr)方法,
有数组读取到的内容存到数组,方法的返回值表示读取到的有效字节个数,
没数组读取到的内容存到read方法的返回值,
但是只要读不到都返回-1,就可以定义变量接收read方法的返回值,循环赋值判断不等于-1就可以一直读
套路:
int ch;
while(()!=-1){}//()当成一个整体,不要漏掉里面的()括号!!!记忆!!!
字节输入流一个读一个字节和一个读一个字节数组的代码总结如下:(能够理解读取数据read(byte[])方法)
流的关闭原则：先开后关，后开先关。

12.
字符流,跟字节流的用法几乎一样,要注意的是字符输出流有内置数组,其他把字节换成字符用!
java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。
- public void close() ：关闭此流,并释放与此流相关联的任何系统资源。    
- public int read()： 从输入流读取一个字符。 
- public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。

13.
java.io.FileReader类是读取字符文件的便利类
构造方法
- FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。   
- FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。  
当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。

14.
字符输出流有内置数组,先写到内置数组缓冲区,满了刷新到文件,
不满残留内置数组,文件没有,
要手动调用输出流的close方法,关闭流之前,刷新内置数组数据到文件中
java.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。
- public abstract void close() ：关闭此输出流,并释放与此流相关联的任何系统资源。  
- public abstract void flush() ：刷新此输出流.并强制任何缓冲的输出字符被写出。  
- public void write(int c) ：写出一个字符。
- public void write(char[] cbuf)：将 b.length字符从指定的字符数组,写出此输出流。  
- public abstract void write(char[] b, int off, int len) ：从指定的字符数组写出 len字符，从偏移量 off开始输出到此输出流。  
- public void write(String str) ：写出一个字符串。//多了写直接写字符串,字节流把字符串变成字节数组写过去,调用getBytes()得到字节数组

15.
java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字符缓冲区。
构造方法
- FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。   
- FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。  
当你创建一个流出对象时，必须传入一个文件路径，类似于FileOutputStream。构造方法没有文件帮你创建,有文件清空,不想清空,追加,逗号,true表示追加,不清空,在后面增加

16.
1. 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。
2. 未调用close方法，数据只是保存到了缓冲区数组，并未写出到文件中。

17.
因为内置缓冲区数组的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。
- flush ：刷新缓冲区，流对象可以继续使用。
- close ：关闭流，释放系统资源。关闭前会刷新缓冲区。
小贴士：即便是flush方法写出了数据，操作的最后还是建议要调用close方法，来释放系统资源。

18.
写出其他数据,(能够使用FileWriter写数据的5个方法)
1.写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream
2.写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便，
3.追加和换行：操作类似于FileOutputStream。(能够使用FileWriter写数据实现换行和追加写)
小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。其他图片视频音频用字节流,拷贝,秒杀,啥都可以!!!

19.
还可以使用JDK7优化后的try-with-resource 语句，该语句确保了每个资源,在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的流对象。
写在()里面的流对象对应的类都实现了自动关闭接口AutoCloseable
try (创建流对象语句，如果多个,使用';'隔开) {
	// 读写数据
} catch (IOException e) {
	e.printStackTrace();
}

20.
Properties 类除了原来双列集合的功能,还表示了一个持久的属性集,属性列表中每个键及其对应值都是一个字符串 ;Properties  可保存在流(写)中或从流中加载(读)
java.util.Properties 继承于Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。
Properties 类表示了一个持久的属性集合(属性列表中每个键及其对应值都是一个字符串),Properties  可保存在流中store,或从流中加载load,Properties类,创建对象,调用方法,简单
21.
构造方法
- public Properties() :创建一个空的属性列表。
基本的存储方法
- public Object setProperty(String key, String value) ： 保存一对属性。  
- public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。
- public Set<String> stringPropertyNames() ：所有键的名称的集合。
22.
与流相关的方法,(能够使用Properties的load方法加载文件中的配置信息)
- public void load(InputStream inStream)： 从字节输入流中读取关联的文件到集合中,一般存储键值对。 
参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。



day10:

1.
缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类：
- 字节缓冲流：BufferedInputStream，BufferedOutputStream 
- 字符缓冲流：BufferedReader，BufferedWriter
缓冲流的基本原理，都是在创建流对象的时候，会创建一个内置8192的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数(输入输出次数)，从而提高读写的效率。

2.
字节缓冲流
构造方法
- public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 
- public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。

3.
字符缓冲流
构造方法
- public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 
- public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。

4,
特有方法
字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。
- BufferedReader：public String readLine(): 读一行文字,读不到换行符号
- BufferedWriter：public void newLine(): 新建一行,写一行,换行,无敌的,每个操作系统都表示换行

5.
ASCII字符集 ：
ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。
基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。

ISO-8859-1字符集：

- 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。
- ISO-5559-1使用单字节编码，兼容ASCII编码。


GBxxx字符集：

- GB就是国标的意思，是为了显示中文而设计的一套字符集。
- GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的"全角"字符，而原来在127号以下的那些就叫"半角"字符了。
- GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。
- GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。

Unicode字符集 ：

- Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。
- 它最多使用4个字节的数字,来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。
- UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求,所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：
  1. 128个US-ASCII字符，只需一个字节编码。
  2. 拉丁文等字符，需要二个字节编码。 
  3. 大部分常用字（含中文），使用三个字节编码。
  4. 其他极少使用的Unicode辅助字符，使用四字节编码。



6.
转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集.将其解码为字符。它的字符集,可以由名称指定，也可以接受平台的默认字符集。 
构造方法//字符流=字节流+码表,转换
- InputStreamReader(InputStream in): 创建一个使用默认字符集的字符输入流。 字节流到字符流的桥梁
- InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符输入流。

7.
转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集,将字符编码为字节。它的字符集,可以由名称指定，也可以接受平台的默认字符集。 
构造方法
- OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符输出流。 ,字符流到字节流的桥梁
- OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符输出流。

8.
总结:不出现乱码,把握一个原则即可:是什么样的文件就用什么编码来读写,通过转换流类的构造方法,字符串编码指定编码即可!!!

9.
Java 提供了一种对象序列化的机制。用一个字节序列,可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的数据等信息。字节序列,写出到文件之后，相当于,文件中持久保存了一个对象的信息。 
反之，该字节序列,还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，可以重新用来在内存中创建对象。

10.
java.io.ObjectOutputStream 类，将Java对象写到文件,实现对象的持久存储。
构造方法
- public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。

11.
序列化操作
1. 一个对象要想序列化，必须满足两个条件:
- 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口,读作序列化接口，不实现此接口的类,将不会使任何状态,序列化或反序列化，会抛出NotSerializableException 。
- 该类的所有属性必须是可序列化的。如果有一个属性不需要序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。//

12.
ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据,恢复为对象。 
构造方法
- public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。
反序列化操作1
如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法：
- public final Object readObject () : 读取一个对象。

13.
另外，当JVM反序列化对象时，能找到class文件，但是class文件,在序列化对象(属性)之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因通常是：
- 该类的序列版本号,与从流中读取的类描述的版本号,不匹配 
Serializable 接口,给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于,验证序列化的对象,和对应类是否,版本匹配。

14.
特点:打印流只操作数据目的,意思是打印流没有读的功能,只有写或者打印,操作数据到目的地,比如文件或者控制台(这句话选择题经常考,记忆,能够说出打印流的特点)
public PrintStream(String fileName)： 使用指定的文件名,创建一个新的打印流。


day11:

1.
软件结构:
C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。
B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。

2.
TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。
它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部,包含一系列的,用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议,来完成自己的需求。

3.
TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。
- 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。
  - 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。
  - 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。
  - 第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。
完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等
   
4.
UDP：用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。
传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。
每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等。

5.
网络编程三要素,巧记3个p,ip,port,protocol

6.
IPv4：是一个32位的二进制数，通常被分为4个字节
IPv6:重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数

7.
如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。
- 端口号：用两个字节表示的整数，它的取值范围是0~65535(刚好是char类型的范围)。其中，0~1023之间的端口号,用于一些知名的网络服务和应用，
普通的应用程序,需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。
利用协议+IP地址+端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信,就可以利用这个标识与其它进程进行交互。

8.
TCP通信,能实现两台计算机之间的数据交互，通信的两端，要严格区分客户端（Client）与服务端（Server）。
两端通信步骤：
1. 服务端程序，需要事先启动，等待客户端的连接。//高冷的女神
2. 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。//卑微的屌丝男

9.
在Java中，提供了两个类,用于实现,TCP通信程序：//万物皆类型,万物皆对象,类模拟一类事物
1. 客户端：java.net.Socket 类表示。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。
2. 服务端：java.net.ServerSocket 类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。

10.
public Socket(String host, int port) :创建套接字对象,并将其连接到,指定主机上(服务器)的ip,指定(服务器)的端口号。如果指定的host字符串的是null(即String host = null;) ，则相当于指定地址为回送地址。  
小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。

11.
成员方法

- public InputStream getInputStream() ： 返回此套接字的输入流,读取服务器写过来的数据
  - 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作,也关联该通道。
  - 关闭生成的InputStream,也将关闭相关的Socket。
- public OutputStream getOutputStream() ： 返回此套接字的输出流,把数据写到服务器
  - 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作,也关联该通道。
  - 关闭生成的OutputStream,也将关闭相关的Socket。
- public void close() ：关闭此套接字。关闭客户端//网络关闭
  - 一旦一个socket被关闭，它不可再使用。
  - 关闭此socket,也将关闭相关的InputStream和OutputStream 。 
- public void shutdownOutput() ： 禁用此套接字客户端的输出流。//单独关闭流,网络没有关闭 
  - 任何先前写出的数据将被发送到服务器，随后终止输出流。 

12.
ServerSocket类：这个类,实现了服务器套接字，该对象,等待通过网络的请求。
构造方法
- public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。

13.
成员方法//接收
- public Socket accept() ：接收,客户端的请求,侦听监听并接受连接，返回一个新的Socket对象，用于和客户端,实现通信。该方法会一直阻塞(暂时等待,如交通阻塞),直到建立连接。 

14.
优化实现, Socket accept = serverSocket.accept();//注意,这里会阻塞,不要写在不断开启的子线程里面,否则消耗资源造成死机!!!



day12:

1.
函数式接口在Java中是指：有且只有一个抽象方法的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda()->{}才能顺利地进行推导。
2.
与@Override注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：@FunctionalInterface。
一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。
3.
双冒号::为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案,已经存在于某个方法的实现中，那么则可以通过双冒号,来引用该方法作为Lambda的替代者。

4.
this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方法引用。
如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。

5.
由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用类名称::new的格式表示。

6.
数组的构造器引用,int[] arr = new int[3];//int[]::new

7.
java.util.function.Supplier<T>接口仅包含一个无参的方法：T get()。用来获取一个,泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象数据。//简单记,赋值T类型产生,T类型对象,也就是一个生产者,通过get方法,用来(得到)生产任意类型的对象东西!!!

8.
java.util.function.Consumer<T>接口则正好相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型参数决定。简单记,它的accept方法,接收T类型的参数,并在重写方法体里面使用,即使用参数做事情,消费者!!!

9.
默认方法：andThen,二次消费,二次使用,链式调用(可选方法,了解)
如果一个方法的参数和返回值全都是Consumer类型，那么就可以实现效果：消费一个数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是Consumer接口中的default默认方法andThen。下面是JDK的源代码：//Consumer接口andThen里面的,只被接口类型类型东西调用

10.



day13:

1.
Predicate接口,测试参数真假,用来条件判断,还有与或非连接
Predicate接口中包含一个抽象方法：boolean test(T t)。用于一个条件判断的场景.
默认方法：and,并且,判断两个条件是否同时成立
默认方法：or,或者,判断两个条件是否有一个或者两个成立
默认方法：negate,取反,得到判断条件相反的结果

2.
Function接口中最主要的抽象方法为：R apply(T t)，根据类型T的参数获取类型R的结果。使用的场景例如：将String类型转换为Integer类型。
//把T变成字符串类型,把R变成整数类型,就知道这个方法把字符串变成整数

3.
默认方法：andThen,第一个东西调用方法完毕的结果,给第二个东西当做参数,再次利用,得到结果,说白了就是消费上一次调用apply方法的结果

4.
- 延迟方法：只是在拼接Lambda函数模型的方法，并不立即执行得到结果。
- 终结方法：根据拼好的Lambda函数模型，立即执行得到结果值的方法。

通常情况下，这些常用的函数式接口中唯一的抽象方法为终结方法，而默认方法为延迟方法。但这并不是绝对的。下面的表格中进行了方法分类的整理：

  接口名称     	方法名称   	抽象/默认	延迟/终结
  Supplier 	get    	抽象   	终结   
  Consumer 	accept 	抽象   	终结   
           	andThen	默认   	延迟   
  Predicate	test   	抽象   	终结   
           	and    	默认   	延迟   
           	or     	默认   	延迟   
           	negate 	默认   	延迟   
  Function 	apply  	抽象   	终结   
           	andThen	默认   	延迟   
5.“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。
list.stream()
          	.filter(s -> s.startsWith("张"))//lambda省略格式写法
            .filter(s -> s.length() == 3)
            .forEach(System.out::println);//用下方法引用
6.
获取一个流,非常简单，有以下几种常用的方式：

- 所有的Collection单列集合都可以通过stream()默认方法获取流；
- Stream接口的静态方法of可以获取数组对应的流。

7.
java.util.Map接口不是Collection的子接口，且其K-V数据结构不符合流元素的单一特征Stream<T>，所以获取对应的流需要分key、value或entry等情况

8.
如果使用的不是集合而是数组，由于数组对象不可能添加默认方法，所以Stream接口中提供了静态方法of，使用很简单：Stream<String> stream = Stream.of(array);

9.
- 终结方法：返回值类型不再是Stream接口自身类型的方法，因此不再支持类似StringBuilder那样的链式调用。本小节中，终结方法包括count和forEach方法。
- 非终结方法：返回值类型仍然是Stream接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为非终结方法。）

10.
基本使用

Stream流中的filter方法基本使用
统计个数：count,统计流中元素个数
取用前几个：limit,限制截取,有限截取,产生新的流
跳过前几个：skip,跳过前几个,产生新的流
映射：map,把调用方法的流变成另一个流,即把流的元素类型转换改变即可
组合：concat,静态方法,传入两个流,进行合并

逐一处理：forEach,遍历,消费每一个元素,一般用于打印元素
虽然方法名字叫forEach，但是与增强for循环中的“for-each”昵称不同，该方法并不保证元素的逐一消费动作,在流中是被有序执行的(选择题考,记记就好)。

11.
总结：函数拼接与终结方法

在上述介绍的各种方法中，凡是返回值仍然为Stream接口的为函数拼接方法，它们支持链式调用；而返回值不再为Stream接口的为终结方法，不再支持链式调用。如下表所示：

  方法名    	方法作用 	方法种类	是否支持链式调用
  count  	统计个数 	终结  		否       
  forEach	逐一处理 	终结  		否       
  filter 	过滤   		函数拼接	是       
  skip   	跳过前几个	函数拼接	是       
  map    	映射   		函数拼接	是       
  concat 	组合   		函数拼接	是       
  limit  	取用前几个	函数拼接	是       

12.
并发流,流并发,都是同一个意思,让流实现并发操作
流的并发方法,跟下面的单列集合的并发流效果,本质上是一样的,都是并发
Stream的父接口java.util.stream.BaseStream中定义了一个parallel方法
在通过集合获取流时，也可以直接调用parallelStream方法来直接获取支持并发操作的流。

13.
流的collect收集方法(自动选你想要的),传入收集工具类调用方法转换为集合
直接用,下面的这一波,有空了解一下,看看就好:
Stream流提供collect方法，其参数需要一个java.util.stream.Collector<T,A, R>接口对象来指定收集到哪种集合中。
幸运的是，java.util.stream.Collectors收集器工具类提供一些方法，可以作为Collector接口的实例：
- public static <T> Collector<T, ?, List<T>> toList()：转换为List集合。
- public static <T> Collector<T, ?, Set<T>> toSet()：转换为Set集合。



===第二部===

======================================================第二阶段==================================================
day14:


1.
存储数据的仓库. 其本质是一个文件系统，数据库按照特定的格式将数据存储起来，用户可以对数据库中的数据进行增加，修改，删除及查询操作。

2.
MYSQL：开源免费的数据库，小型的数据库.已经被Oracle收购了.MySQL6.x版本也开始收费。
Oracle：收费的大型数据库，Oracle公司的产品。Oracle收购SUN公司，收购MYSQL。
DB2 ：IBM公司的数据库产品,收费的。常应用在银行系统中.
SQLServer：MicroSoft 公司收费的中型的数据库。C#、.net等语言常使用。
SyBase：已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。
SQLite: 嵌入式的小型数据库，应用在手机端。

3.
常用数据库：MYSQL，Oracle
在web应用中，使用的最多的就是MySQL数据库，原因如下：
1. 开源、免费
2. 功能足够强大，足以应付web应用开发（最高支持千万级别的并发访问）

4.
数据库管理系统（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。
用户通过数据库管理系统访问数据库中表内的数据

5.
结构化查询语言(Structured Query Language)简称SQL,SQL语句就是对数据库进行操作的一种语言。

6.
1). DDL(Data Definition Language)数据定义语言,用于创建、修改、删除数据库和表(了解)
   用来定义数据库对象：数据库，表，列等。关键字：create(创建), drop(删除),alter(修改)等
2). DML(Data Manipulation Language)数据操作语言(掌握)
   用来对数据库中表中的数据进行增删改。关键字：insert(添加数据), delete(删除数据), update(修改数据)等
3). DCL(Data Control Language)数据控制语言(了解)
   用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE等
4). TCL(Transaction Control Language) 事务控制语言
   用于控制数据库的事务操作，关键字; COMMIT，SAVEPOINT，ROLLBACK等
5). DQL(Data Query Language) 数据查询语言(重中之重)
   DQL语言并不是属于MYSQL官方的分类，但是对数据库的操作最多就是查询，所以
   我们的程序员把查询语句的语句称作为DQL语言

7.
1). SQL语句可以单行或多行书写。SQL语句是没有分号的，在cmd中写SQL语句就要加分号，";"是cmd中一句命令的结束标识
2). 可使用空格和缩进来增强语句的可读性。
3). MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。
       SELECT 	* FROM student;      
4). 3种注释(针对在"SQLYog"中写SQL语句)
   单行注释: --空格 注释内容 或 # 注释内容(mysql特有)
   多行注释: /* 注释 */

8.
 DDL语句//建库建表(带有字段),搞结构
 一.创建数据库
1). 直接创建数据库
   CREATE DATABASE 数据库名;
2). 判断是否存在并创建数据库
   CREATE DATABASE IF NOT EXISTS 数据库名;
3). 创建数据库并指定字符集(编码表)
   CREATE DATABASE 数据库名 CHARACTER SET 字符集;
二.查看数据库,show
1). 查看所有的数据库
   SHOW databases;
   
2). 查看某个数据库的定义信息
   SHOW CREATE DATABASE 数据库名;
三.修改数据库,alter
修改数据库字符集格式
ALTER DATABASE 数据库名 CHARACTER SET 字符集;
四.删除数据库
删除数据库,用drop丢弃而不是delete!!!
DROP DATABASE 数据库名;
五.使用数据库
使用数据库,要注意,需要记忆!!!
1). 查看正在使用的数据库
   SELECT DATABASE();
2). 使用/切换数据库
   USE 数据库名;


9.DDL操作表
前提先使用某个数据库!!!
一.创建表,create,跟数据库类似,中间插入(),指定字段和类型,记忆!!!
CREATE TABLE 表名 (字段名1 字段类型1, 字段名2 字段类型2…);



建议写成如下格式:

    CREATE TABLE 表名 (
    字段名1 字段类型1, 
    字段名2 字段类型2
    );
二.
MySQL数据类型:

MySQL中的我们常用的数据类型如下:
类型		描述
int		整型
double		浮点型
varchar		字符串型
date		日期类型,格式为yyyy-MM-dd,只有年月日,没有时分秒

扩展:char和varchar的区别:char固定长度,不够用空格补全,一般使用varchar:
三.
查看表(了解),比数据库了show,多了desc表名查看表结构,如里面的字段类型和默认值等,记忆!!!

1). 查看某个数据库中的所有表
   SHOW TABLES;
2). 查看表结构//记忆
   DESC 表名;
3). 查看创建表的SQL语句(掌握)
   SHOW CREATE TABLE 表名;
四.
快速创建一个表结构相同的表,like,像哪个旧表,即创建新表像哪个旧表,记忆!!!

CREATE TABLE 新表名 LIKE 旧表名;

五.
删除表,drop,跟删除数据库几乎一样

1. 直接删除表
   DROP TABLE 表名;
2. 判断表是否存在并删除表
   DROP TABLE IF EXISTS 表名;
六.
修改表结构(了解!!!)
修改表结构使用不是很频繁，只需要了解，不需要记太多,等需要使用的时候再回来查即可!!!
1. 添加表列(修改表增加字段和类型)
   ALTER TABLE 表名 ADD 列名 类型;
七.
修改列类型(修改表修改已有字段类型)
ALTER TABLE 表名 MODIFY 列名 新的类型;
八.
删除列(修改表丢弃删除字段,所以不要类型!!!,要特别注意!!!)
ALTER TABLE 表名 DROP 列名;

九.
修改表名(重命名旧表名到新的名字)
RENAME TABLE 表名 TO 新表名;

十.
修改表字符集(跟数据库类似,不用记)
ALTER TABLE 表名 character set 字符集;


10.
DML语句(重点掌握)
一.
-- 插入全部字段
- 所有的字段名都写出来
  INSERT INTO 表名 (字段名1, 字段名2, 字段名3…) VALUES (值1, 值2, 值3);
- 不写字段名,简化格式,要插入所有
  INSERT INTO 表名 VALUES (值1, 值2, 值3…);
-- 插入部分数据
   INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);
   没有添加数据的字段会使用NULL赋值
注意
- 值与字段必须对应，个数相同，类型相同
- 值的数据大小必须在字段的长度范围内
- 除了数值类型外，其它的字段类型的值必须使用引号引起来。（建议单引号,好看点）
- 如果要插入空值，可以不写字段，或者插入null表示


11.
DOS命令窗口操作数据乱码问题的解决(如插入中文乱码问题):
快捷设置,常用set names gbk;即临时设置所有字符集编码(名字)为gbk,记忆!!!

12.
蠕虫复制,(创建新表像哪个旧的表,然后插入到新表,选择来自旧表的数据,记忆!!!)
什么是蠕虫复制：在已有的数据基础之上，将原来的数据进行复制，插入到对应的表中
语法格式：INSERT INTO 表名1 SELECT * FROM 表名2;
作用:将表名2中的数据复制到表名1中


部分复制(新表要()指定字段,选择旧表字段,记忆!!!):
注意：如复制student表中name,age字段数据到student2表中使用如下格式:
INSERT INTO student2(NAME, age) SELECT NAME, age FROM student;



13.
更新表记录(更新表设置字段进行赋值,可增加where条件,简单)
1. 不带条件修改数据
   UPDATE 表名 SET 字段名=值;
2. 带条件修改数据
   UPDATE 表名 SET 字段名=值 WHERE 字段名=值;
3. 关键字说明
       UPDATE: 修改数据
       SET: 修改哪些字段
       WHERE: 指定条件
14.
删除表记录(删除数据要告诉我来自哪个表,delete from表名,简单)

1. 不带条件删除数据
   DELETE FROM 表名;
2. 带条件删除数据
   DELETE FROM 表名 WHERE 字段名=值;
3. truncate删除表记录
   TRUNCATE TABLE 表名;
   truncate和delete的区别：
   - delete是将表中的数据一条一条删除,效率低
   - truncate是将整个表摧毁，重新创建一个新的表,新的表结构和原来表结构一模一样,效率高

15.
DQL(重中之重)

查询不会对数据库中的数据进行修改.只是一种显示数据的方式

使用*表示所有列(即星号,代表所有字段)

SELECT * FROM 表名;

写出查询每列的名称

SELECT 字段名1, 字段名2, 字段名3, ... FROM 表名;


16.
别名查询,(as作为别名,可以省略as,记忆!!!)

1. 查询时给列、表指定别名需要使用AS关键字
2. 使用别名的好处是方便观看和处理查询到的数据
   SELECT 字段名1 AS 别名, 字段名2 AS 别名... FROM 表名;
   SELECT 字段名1 AS 别名, 字段名2 AS 别名... FROM 表名 AS 表别名;
   注意:
   查询给表取别名目前还看不到效果，需要到多表查询的时候才能体现出好处
   AS关键字可以省略

17.
清除重复值(去重查询),简单查询,中插distinct去重

1. 查询指定列并且结果不出现重复数据
   SELECT DISTINCT 字段名 FROM 表名;

18.
运算查询,查询结果参与运算(没有改变数据库中的数据)

1. 某列数据和固定值运算
   SELECT 列名1 + 固定值 FROM 表名;
2. 某列数据和其他列数据参与运算
   SELECT 列名1 + 列名2 FROM 表名;
   注意: 参与运算的必须是数值类型
19.
条件查询(很重要,含比较,逻辑,范围,模糊像什么匹配通配符)
语法格式：SELECT 字段名 FROM 表名 WHERE 条件;

20.
>大于 

<小于

<=小于等于

>=大于等于

=等于,注意一个=!!!

<>、!=不等于,有两个,要注意!!!

21.
逻辑运算符,与或非,跟java类似,简单

and 多个条件同时满足,并且

or 多个条件其中一个满足,或者

not 不满足,取反

22.
in关键字,在()范围里面,可以理解为是或者的优化,或者集合

语法格式：SELECT 字段名 FROM 表名 WHERE 字段 in (数据1, 数据2...);

in里面的每个数据都会作为一次条件，只要满足条件的就会显示
NOT IN,不在()集合范围内

23.
范围,在什么和什么之间,注意包括相等的情况,简单

BETWEEN 值1 AND 值2 表示从值1到值2范围，包头又包尾


24.
like,关键字,像什么,模糊查询,跟通配符一起使用,记忆!!!

LIKE表示模糊查询

SELECT * FROM 表名 WHERE 字段名 LIKE '通配符字符串';

满足通配符字符串规则的数据就会显示出来

所谓的通配符字符串就是含有通配符的字符串

MySQL通配符有两个：

%: 表示0个或多个字符(任意个字符)

_: 表示一个字符



day15:
1.
通过ORDER BY子句，可以将查询出的结果进行排序(排序只是显示方式,不会影响数据库中数据原来的顺序)
SELECT 字段名 FROM 表名 WHERE 字段=值 ORDER BY 字段名 [ASC|DESC];
ASC: 升序, 默认不写是升序
DESC: 降序

2.
组合排序,多字段排序
SELECT 字段名 FROM 表名 WHERE 字段=值 ORDER BY 字段名1 [ASC|DESC], 字段名2 [ASC|DESC];

3.
聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个结果值。另外,聚合函数会忽略空值!!!
五个聚合函数：
count： 统计指定列记录数，记录为NULL的不统计
sum： 计算指定列的数值和，如果不是数值类型，那么计算结果为0
max： 计算指定列的最大值
min： 计算指定列的最小值
avg： 计算指定列的平均值，如果不是数值类型，那么计算结果为0

4.
IFNULL(expr1, expr2)的用法：假如expr1 不为 NULL，则 IFNULL() 的返回值为 expr1; 否则其返回值为expr2

5.
分组查询是指使用 GROUP BY语句对查询信息进行分组，相同数据作为一组
SELECT 字段1,字段2... FROM 表名 GROUP BY 分组字段 [HAVING 条件];

6.
GROUP BY将分组字段结果中相同内容作为一组，并且返回每组的第一条数据，所以单独分组没什么用处。分组的目的就是为了统计，一般分组会跟聚合函数一起使用。

7.
having与where的区别:(巧记,bye(by having),后面再聚!!!)

- having是在分组后对数据进行过滤
- where是在分组前对数据进行过滤
- having后面可以使用聚合函数
- where后面不可以使用聚合函数

8.
LIMIT是限制的意思，所以LIMIT的作用就是限制查询记录的条数。
SELECT *|字段列表 [as 别名] FROM 表名 [WHERE子句] [GROUP BY子句][HAVING子句][ORDER BY子句][LIMIT子句];

9.
LIMIT语法格式：
LIMIT offset,length;   或者limit length;
offset是指偏移量，可以认为是跳过的记录数量，默认为0
length是指需要显示的总记录数

10.
对表中的数据进行进一步的限制，保证数据的正确性、有效性和完整性。
约束种类：
- PRIMARY KEY: 主键,非空,唯一
- UNIQUE: 唯一，表示使用了这个约束的字段不能重复
- NOT NULL: 非空，表示使用了这个约束的字段不能为null
- DEFAULT: 默认,表示如果这个字段没有插入值的话，会赋一个默认值
- FOREIGN KEY: 外键(难点)

11.
创建主键方式：

1). 在创建表的时候给字段添加主键
   字段名 字段类型 PRIMARY KEY
2). 在已有表中,修改表添加主键
   ALTER TABLE 表名 ADD PRIMARY KEY(字段名);
3).删除主键:ALTER TABLE 表名 DROP PRIMARY KEY;
4).主键如果让我们自己添加很有可能重复,我们通常希望在每次插入新记录时,数据库自动生成主键字段的值
   AUTO_INCREMENT 表示自动增长(字段类型必须是整数类型才行)

12.
DELETE和TRUNCATE,在主键自动增长里面的区别:记忆后者即可
- DELETE 删除表中的数据，但不重置AUTO_INCREMENT的值。
TRUNCATE 摧毁表，重建表,从新开始，AUTO_INCREMENT重置为1,而delete不会重置而是后面追加

13.
疑问:如果一个字段设置了非空与唯一约束，该字段与主键的区别:
- 一张表中只有一个字段可以设置为主键
- 一张表中可以多个字段非空与唯一约束
- 主键可以自动增长，非空与唯一约束的字段不能自动增长

14.
一张表中的某个字段.引用了另一张表的主键字段
主表： 约束别人的表
副表/从表： 使用别人的数据，被别人约束的表

15.
1. 新建表时增加外键：
   [CONSTRAINT] [外键约束名称] FOREIGN KEY(外键字段名) REFERENCES 主表名(主键字段名)
   关键字解释：
   CONSTRAINT -- 约束关键字
   FOREIGN KEY(外键字段名) –- 某个字段作为外键
   REFERENCES -- 主表名(主键字段名) 表示参照主表中的某个字段
2. 已有表增加外键,即修改表增加外键谁,来引用主表主键：
   ALTER TABLE 从表 ADD [CONSTRAINT] [外键约束名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主键字段名);

16.
 删除外键

ALTER TABLE 从表 drop foreign key 外键名称;

17.
什么是级联操作：
在修改和删除主表的主键时，同时更新或删除副表的外键值，称为级联操作
ON UPDATE CASCADE -- 级联更新，主键发生更新时，外键也会更新
ON DELETE CASCADE -- 级联删除，主键发生删除时，外键也会删除

18.
第一范式：每一列不能再拆分
第二范式：

1. 一张表只描述一件事情
2. 表中的每一个字段都依赖于主键
第三范式：从表的外键必须使用主表的主键



注:
count(*)
ifnull(id,0)
select * from student not (name like "wang%");


day16:

tips:三大定:定表,定连接,定条件.

1.
内连接
1).隐式内连接：看不到JOIN关键字，条件使用WHERE指定:SELECT 字段名 FROM 左表, 右表 WHERE 条件
2).显示内连接：使用INNER JOIN ... ON语句, 可以省略INNER:SELECT 字段名 FROM 左表 INNER JOIN 右表 ON 条件

2.
左外连接：使用LEFT OUTER JOIN ... ON，OUTER可以省略
SELECT 字段名 FROM 左表 LEFT OUTER JOIN 右表 ON 条件；
用左边表的记录去匹配右边表的记录，如果符合条件的则显示；否则，显示NULL
可以理解为：在内连接的基础上保证左表的数据全部显示

3.
右外连接：使用RIGHT OUTER JOIN ... ON，OUTER可以省略
SELECT 字段名 FROM 左表 RIGHT OUTER JOIN 右表 ON 条件；
用右边表的记录去匹配左边表的记录，如果符合条件的则显示；否则，显示NULL
可以理解为：在内连接的基础上保证右表的数据全部显示

4.子查询
一条SELECT语句结果作为另一条SELECT语法一部分（查询条件，查询结果，表）
1).
子查询结果只要是单列，肯定在WHERE后面作为条件
SELECT 查询字段 FROM 表 WHERE 字段=（子查询）;
2).
子查询结果是单列多行的时候
子查询结果只要是单列，肯定在WHERE后面作为条件
子查询结果是单列多行，结果集类似于一个数组，父查询使用IN运算符
SELECT 查询字段 FROM 表 WHERE 字段 IN （子查询）;
3).
子查询结果只要是多列，肯定在FROM后面作为表
SELECT 查询字段 FROM （子查询） 表别名 WHERE 条件
子查询作为表需要取别名，否则这张表没用名称无法访问表中的字段
SELECT * FROM dept d, (SELECT * FROM emp WHERE join_date > '2011-1-1') e WHERE e.dept_id = d.id;

5.
MYSQL中可以有两种方式进行事务的操作：1.手动提交事务，2.自动提交事务

6.手动提交事务
  SQL语句             	描述  
  start transaction;	开启事务
  commit;           	提交事务
  rollback;         	回滚事务
手动提交事务使用步骤：
    第1种情况：开启事务 -> 执行SQL语句 -> 成功 -> 提交事务
    第2种情况：开启事务 -> 执行SQL语句 -> 失败 -> 回滚事务

如果事务中SQL语句没有问题，commit提交事务，会对数据库数据的数据进行改变。
如果事务中SQL语句有问题，rollback回滚事务，会回退到开启事务时的状态。


7.
自动提交事务
MySQL的每一条DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，执行完毕自动提交事务，MySQL默认开始自动提交事务

show variables like '%commit%'; 关闭自动提交set autocommit = 0;  打开set autocommit = 1;

8.
事务原理:
事务开启之后, 所有的操作都会临时保存到事务日志, 事务日志只有在得到commit命令才会同步到数据表中，其他任何情况都会清空事务日志(rollback，断开连接)

9.
在某些成功的操作完成之后，后续的操作有可能成功有可能失败，但是不管成功还是失败，前面操作都已经成功，可以在当前成功的位置设置一个回滚点。
可以供后续失败操作返回到该位置，而不是返回所有操作，这个点称之为回滚点。
设置回滚点语法：savepoint 回滚点名字;
回到回滚点语法: rollback to 回滚点名字;

10.
事务四大特性:

原子性（Atomicity）
事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。

一致性（Consistency）
事务前后数据的完整性必须保持一致

隔离性（Isolation）
是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离，不能相互影响。

持久性（Durability）
指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

11.
MySQL数据库有四种隔离级别：上面的级别最低，下面的级别最高。“是”表示会出现这种问题，“否”表示不会出现这种问题。

  级别  	名字  	隔离级别            	脏读  	不可重复读	幻读  	数据库默认隔离级别        
  1   	读未提交	read uncommitted	是   	是    		是   	                 
  2   	读已提交	read committed  	否   	是    		是   	Oracle和SQL Server
  3   	可重复读	repeatable read 	否   	否    		是   	MySQL            
  4   	串行化 	serializable    	否   	否    	否   	                 

MySQL事务隔离级别相关的命令
show variables like '%isolation%';
-- 或
select @@tx_isolation;

set global transaction isolation level 级别字符串;（修改全局的）
set session transaction isolation level read uncommitted;(修改当次)

12.创建用户:
CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';

eg:
-- user1用户只能在localhost这个IP登录mysql服务器
CREATE USER 'user1'@'localhost' IDENTIFIED BY '123';
-- user2用户可以在任何电脑上登录mysql服务器
CREATE USER 'user2'@'%' IDENTIFIED BY '123';

授权
GRANT 权限1, 权限2... ON 数据库名.表名 TO '用户名'@'主机名';
撤销授权
REVOKE  权限1, 权限2... ON 数据库.表名 FROM '用户名'@'主机名';
查看权限
SHOW GRANTS FOR '用户名'@'主机名';
删除用户
DROP USER '用户名'@'主机名';

13.
修改管理员密码
mysqladmin -uroot -p password 新密码  -- 新密码不需要加上引号

修改普通用户密码
set password for '用户名'@'主机名' = password('新密码');


day17:

1.
JDBC规范定义接口，具体的实现由各大数据库厂商来实现
JDBC是Java访问数据库的标准规范。真正怎么操作数据库还需要具体的实现类，也就是数据库驱动。每个数据库厂商根据自家数据库的通信格式编写好自己数据库的驱动。
所以我们只需要会调用JDBC接口中的方法即可。

2.
JDBC四个核心对象
这几个类都是在java.sql包中
1. DriverManager: 用于注册驱动、以及获取Connection连接对象
2. Connection: 表示与数据库创建的连接
3. Statement: 执行SQL语句的对象、将SQL语句发送到mysql服务器进行执行。
4. ResultSet: 结果集或一张虚拟表，查询数据的时候查询到的所有结果全部在ResultSet对象中

3.
JDBC获取连接步骤

1.导入驱动Jar包
2.注册驱动
3.获取连接

4.
DriverManager.registerDriver(驱动对象); 传入对应参数即可(不用)
使用Class.forName("com.mysql.jdbc.Driver");加载驱动，这样驱动只会注册一次
注册MySQL驱动使用Class.forName("com.mysql.jdbc.Driver");

5.
DriverManager.getConnection(url, user, password); 传入对应参数即可

1). String url：连接数据库的URL，用于说明连接数据库的位置
2). String user：数据库的账号
3). String password：数据库的密码
连接数据库的URL地址格式：协议名:子协议://服务器名或IP地址:端口号/数据库名?参数=参数值
MySQL写法：jdbc:mysql://localhost:3306/day24
如果是本地服务器，端口号是默认的3306，则可以简写：jdbc:mysql:///day24

6.
Connection.CreateStatement()
statement.excute(sql)如下:
1).boolean execute(String sql)
此方法可以执行任意sql语句。返回boolean值，表示是否返回ResultSet结果集。仅当执行select语句，且有返回结果时返回true, 其它语句都返回false;
这个方法一般只用于执行DDL语句,而DDL我们一般是直接在工具中使用就可以了。项目中一般不会有执行DDL的需求

2).int executeUpdate(String sql)
根据执行的DML（INSERT、UPDATE、DELETE）语句，返回受影响的行数

3).ResultSet executeQuery(String sql)
根据查询语句返回结果集,只能执行SELECT语句


7.
1). 注册驱动
2). 获取连接
3). 获取Statement对象
4). 使用Statement对象执行SQL语句
5). 释放资源

8.
Connection接口中与事务有关的方法:connection.setAutoCommit(false)
void setAutoCommit(boolean autoCommit) throws SQLException;
false：开启事务， ture：关闭事务

void commit() throws SQLException;
提交事务

void rollback() throws SQLException;
回滚事务

9.
1. 注册驱动
2. 获取连接
3. 获取到Statement
4. 开启事务
5. 使用Statement执行SQL
6. 提交或回滚事务
7. 关闭资源

10.
 prepareStatement()会先将SQL语句发送给数据库预编译。PreparedStatement会引用着预编译后的结果。可以多次传入不同的参数给PreparedStatement对象并执行。减少SQL编译次数，提高效率。
 安全性更高，没有SQL注入的隐患。
 提高了程序的可读性

在java.sql.Connection有获取PreparedSatement对象的方法

void setDouble(int parameterIndex, double x) 
将指定参数设置为给定 Java double 值。

void setFloat(int parameterIndex, float x) 
将指定参数设置为给定 Java REAL 值。 

void setInt(int parameterIndex, int x) 
将指定参数设置为给定 Java int 值。

void setLong(int parameterIndex, long x) 
将指定参数设置为给定 Java long 值。 

void setObject(int parameterIndex, Object x) 
使用给定对象设置指定参数的值。 

void setString(int parameterIndex, String x) 
将指定参数设置为给定 Java String 值。 

ResultSet executeQuery() 
在此 PreparedStatement 对象中执行 SQL 查询，并返回该查询生成的ResultSet对象。

int executeUpdate() 
在此 PreparedStatement 对象中执行 SQL 语句，该语句必须是一个 SQL 数据操作语言（Data Manipulation Language，DML）语句，比如 INSERT、UPDATE 或 DELETE 语句；或者是无返回内容的 SQL 语句，比如 DDL 语句。 


11.
1). 编写SQL语句，未知内容使用?占位："SELECT * FROM user WHERE name=? AND password=?;";
2). 获得PreparedStatement对象
3). 设置实际参数
4). 执行参数化SQL语句
5). 关闭资源


day18:

1.
连接池的概念: 连接池是创建和管理数据库连接的缓冲池技术。连接池就是一个容器，连接池中保存了一些数据库连接，这些连接是可以重复使用的。

2.
1). 连接池在初始化的时候会默认存放n个连接对象并存放到一个容器(LinkedList)中
2). 当需要连接的时候，如果连接池中有连接就直接从连接池中获取，如果连接池中没有则新创建连接，如果连接数大于最大连接数时，如果再有请求需要获取连接则将其添加到等待队列
3). 对于新创建的连接，一般不会直接销毁，它将被放到连接池中等待重复使用,只有当空闲超时后被释放。
4). 对于原本就在连接池中的连接对象，用完之后直接放回连接池中
5). 连接池中的连接数在空闲时会逐渐趋近于最小连接数(核心连接数),连接池在满载时的连接数会接近最大连接数。

3.
 Java为数据库连接池提供了公共的接口: javax.sql.DataSource，各个厂商需要让自己的连接池实现这个接口。这样应用程序可以方便的切换不同厂商的连接池。

4.
 

  参数             	说明      
  initialPoolSize	初始连接数   
  maxPoolSize    	最大连接数   
  checkoutTimeout	最大等待时间  
  maxIdleTime    	最大空闲回收时间

初始连接数：刚创建好连接池的时候准备的连接数量

最大连接数：连接池中最多可以放多少个连接

最大等待时间：连接池中没有连接时最长等待时间

最大空闲回收时间：连接池中的空闲连接多久没有使用就会回收

5.
1). 导入jar包c3p0-0.9.1.2.jar
2). 编写c3p0-config.xml配置文件，配置对应参数
3). 将配置文件放在src目录下
4). 创建连接池对象ComboPooledDataSource，使用默认配置或命名配置
5). 从连接池中获取连接对象
6). 使用连接对象操作数据库
7). 关闭资源


6.
DRUID常用的配置参数

常用的配置参数：

  参数             	说明                                      
  jdbcUrl        	连接数据库的url：mysql : jdbc:mysql://localhost:3306/druid2
  username       	数据库的用户名                                 
  password       	数据库的密码                                  
  driverClassName	驱动类名。根据url自动识别，这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)
  initialSize    	初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时
  maxActive      	最大连接数量                                  
  maxIdle        	已经不再使用，配置了也没效果                          
  minIdle        	最小连接池数量                                 
  maxWait        	获取连接时最大等待时间，单位毫秒。                       
7.
com.alibaba.druid.pool.DruidDataSourceFactory类有创建连接池的方法

    public static DataSource createDataSource(Properties properties)
    创建一个连接池，连接池的参数使用properties中的数据

我们可以看到DRUID连接池在创建的时候需要一个Properties对象来设置参数，所以我们使用properties文件

1. 在src目录下创建一个properties文件，并设置对应参数
2. 加载properties文件的内容到Properties对象中
3. 创建DRUID连接池，使用配置文件中的参数
4. 从DRUID连接池中取出连接
5. 执行SQL语句
6. 关闭资源


day19:

1.
在JdbcTemplate中执行SQL语句的方法大致分为3类：

1. execute：可以执行所有SQL语句，一般用于执行DDL语句。(了解)
2. update：用于执行INSERT、UPDATE、DELETE等DML语句。
3. queryXxx：用于DQL数据查询语句。


2.
JdbcTemplate实现查询
public <T> T queryForObject(String sql, Class<T> requiredType)
执行查询语句，返回一个指定类型的数据。

public Map<String, Object> queryForMap(String sql)
执行查询语句，将一条记录放到一个Map中。这条数据的各个字段名作为map的key，各个字段的值作为map的value


public List<Map<String, Object>> queryForList(String sql)
执行查询语句，返回一个List集合，List中存放的是Map类型的数据。


public <T> List<T> query(String sql, RowMapper<T> rowMapper)
执行查询语句，返回一个List集合，List中存放的是RowMapper指定类型的数据。


3.
public <T> List<T> query(String sql, RowMapper<T> rowMapper)
执行查询语句，返回一个List集合，List中存放的是RowMapper指定类型的数据。

public class BeanPropertyRowMapper<T> implements RowMapper<T>
BeanPropertyRowMapper类实现了RowMapper接口

4.
JDBCTemplate的query方法用于执行SQL语句，简化JDBC的代码。同时还可以在SQL语句中使用？占位，在query方法的Object... args可变参数中传入对应的参数。


5.元数据
connection.getMetaData()调用下面方法
- getURL()：返回一个String类对象，代表数据库的URL。
- getUserName()：返回连接当前数据库管理系统的用户名。
- getDriverName()：返回驱动驱动程序的名称。

6.preparedStatement.getParameterMetaData()调用
- getParameterCount()
  获得指定参数的个数
- getParameterType(int param)
  获得指定参数的sql类型
  并不是所有数据库都支持，使用MySQL时，这个方法只会返回varchar的int值（即12）
- getParameterTypeName(int param)  --- 参数类型名称


7.resultSet.getMetaData()调用
- getColumnCount()
  返回resultset对象的列数
- getColumnName(int column)
  获得指定列的名称
- getColumnTypeName(int column)
  获得指定列的类型


day20:

1.
head标签
一般情况下, 写在head标签内部的内容都不会显示给用户查看, 也就是说一般情况下写在head标签内部的内容我们都看不到.
作用
	指定网站的标题 
	指定网站的关键字/指定网站的描述信息
	外挂一些外部的css/js文件
	添加一些浏览器适配相关的内容


2.
title标签
- 作用
  	专门用于指定网站的标题, 并且这个指定的标题将来还会作为用户保存网站的默认标题
- 注意点:
  	title标签必须写在head标签里面

3.
body标签
- 作用
  	专门用于定义HTML文档中需要显示给用户查看的内容(文字/图片/音频/视频)
- 注意点
  	虽然说有时候你可能将内容写到了别的地方在网页中也能看到, 但是千万不要这么干, 一定要将需要显示的内容写在body中.
  	一对html标签中(一个html开始标签和一个html结束标签)只能有一对body标签

4.
.html语法规范

- 扩展名是html或者htm

- html标签不区分大小写
- html由头(head)和体(body)组成
- 标签是可以嵌套的,标签里面可以放标签  eg: head标签定义在了html标签里面
- 标签一般由起始标签开始，结束标签终止(成对出现)。但是如果标签不修饰内容，可以在标签里结束。

5.标签属性
- 属性是属于标签的，修饰标签，让标签有更多的效果
- 属性一般定义在起始标签里面。 
- 属性一般以 属性=属性值的形式存在
- 属性值一般用 '' 或者“ ” 括起来。 不加引号也是可以的.(不建议使用)

6.
排版标签
字体标签
<font color="字体颜色" size="字体大小(1~7)" face="字体风格">哈哈</font>

标题标签
<hn>标题<hn>  n取值1~6, 1是一级标题, 2是二级标题...

段落标签
<p>段落</p>

粗体标签
<b>内容</b>

斜体标签
<i>内容</i>

下划线标签
<hr/>

换行标签
<br/>

7.
语法:
<img src="图片路径" width="宽" height="高" alt="图片描述" title="用于告诉浏览器, 当鼠标悬停在图片上时, 需要弹出的描述框中显示什么内容"/>

8.
路径问题
2.1相对路径
	相对路径就是每次都从.html文件所在的文件夹开始查找, 我们称之为相对路径
2.1.1同级
	同级就是"图片"和".html文件"存储在同一个文件夹中
	格式: src="QRCode.jpg"
	含义: 在.html文件所在的文件夹中查找名称叫做QRCode.jpg的图片
2.1.2上级
	上级就是"存储图片的位置"和存"储代码的文件夹"在同一个文件夹中
	格式: src="../QRCode.jpg"
	含义：在.html文件所在的文件夹中找到这个文件夹的上一级文件夹, 然后再在上一级文件夹中找到名称叫QRCode.jpg, 其中../ 代表找到当前文件夹的上一级文件夹
2.2绝对路径
	绝对路径就是每次都从指定的盘符开始查找.
绝对路径注意点:
	1.路径中不要出现中文, 否则可能出现未知问题
	2.如果是通过"绝对路径"来指定图片, 不能跨盘符,例如.html文件在C盘, 那么不能去查找D盘图片. 直接打开, 不要使用IDEA

图片路径
- 相对路径
  - ./ 当前目录 (./可以省略)
  - ../ 上级目录
- 绝对路径(从盘符开始, 从网络协议)

9.
列表标签

无序列表
<ul type="类型">
    <li>需要显示的条目内容</li>
    ...
</ul>

注意点
 ul标签和li标签是一个整体,一般情况下ul标签和li标签都是一起出现, 不会单个出现.
 li要定义在ul里面

有序列表
<ol type="类型" start="起始索引">
    <li>需要显示的条目内容</li>
    ...
</ol>

10.
超链接标签

超链接标签的格式:
		<a href="指定需要跳转的目标路径" target="打开的方式">需要展现给用户查看的内容</a>
		target属性取值: 
		_blank：新起页面
		_self：当前页面（默认）

假链接
就是点击之后不会跳转的链接我们称之为假链接.在企业开发前期, 其它界面都没有写出来, 那么我们就不知道应该跳转到什么地方, 所以就只能使用假链接来代替. 
当项目后期其它界面都已经完成时再将假链接体会为真链接
<a href="#">这是一个假链接</a>

11.
表格标签的使用

1.解释说明
	表格标签和列表标签一样, 它是一个组合标签, 所以table/tr/td要么一起出现, 要么一起不出现, 不会单个出现
	tr定义在table里面, td定义在tr里面
2.注意点
	表格标签有一个边框属性, 这个属性决定了边框的宽度. 默认情况下这个属性的值是0, 所以看不到边框
	表格标签和列表标签一样, 它是一个组合标签, 所以table/tr/td要么一起出现, 要么一起不出现, 不会单个出现
	tr定义在table里面, td定义在tr里面

12.
表格中的属性
属性名  作用
width	宽度
border	边框的粗细
align	可以用于table,tr,td
rowspan	跨几行
colspan	跨几列
cellspacing 指定单元格之间的间隔
cellpadding 单元格与内容之间的间隔

13.
表格的其它标签
<table>
	<caption>表格标题</caption>
	<tr>
        <th>第一列的标题</th>
        <th>第二列的标题</th>
        <th>第三列的标题</th>
    </tr>
    ...
</table>

1.caption表格标题
	在表格标签中提供了一个标签专门用来设置表格的标题, 这个标签叫做caption. 只要将标题写在caption标签中, 那么标题就会自动相对于表格的宽度居中
2.th列标题
	在表格标签中提供了一个标签专门用来存储每一列的标题, 这个标签叫做th标签, 只要将当前列的标题存储在这个标签中就会自动居中+加粗文字.
	到此为止我们就发现, 其实表格中有两种单元格, 一种是td, 一种是th. td是专门用来存储数据的, th是专门用来存储当前列的标题的
14.
在html里面锚点的作用: 通过a标签跳转到指定的位置.
 <a id="aId"></a>

 <a href="#aId">回到顶部</a>

15.
video标签
<video src="视频的资源">
</video>

audio标签
<audio src="音频的资源"></auto>


day 21:

1.
表单标签【重点】
- 通过form来定义
常用属性
	action:提交路径,默认是当前页面,#
	method:提交方式,常用的是get和post. 默认就是get
get和post区别
1). get方式提交的数据(请求参数)在地址栏可见(拼接在请求的路径后面), post方式不可见
2). get方式相对不安全, post方式相当安全一些
3). get方式对提交的数据(请求参数)的大小有限制的, post方式没有限制的
form的常见子标签
	input:输入域, 通过type属性来指定类型
	select :选择列表
	textarea：文本域

2.
input：输入类型

type属性,类型是由属性（type）定义的

- text:文本输入框
- password:密码域
- submit：提交按钮
- reset：重置按钮
- button:空白按钮
- radio:单选框
- checkbox:复选框
- file:文件
- hidden:隐藏字段

3.
select :选择菜单
<select name="">
	<option value="">显示的内容</option>
</select>

- option：选择菜单的选项

注意：

- name在select里面指定
- value在option里面指定
- option定义在select里面

4.
textarea:文本域
<textarea rows="20" cols="30" name="introduce"></textarea>
属性：

- cols列
- rows:行

5.
通用属性
1.name

- 作为单选和多选框的分组  
- 作为key上传到后台程序，后台程序通过key得到相对应的value。如果要想把数据提交到后台程序，一定要指定name属性 

2.value

- 给按钮起名字
- 设置提交到服务器的值  name=value

6.
设置默认值
1).
text,password:通过value属性
用户名: <input type="text" name="username" value="zs"/>

2).
radio checkbox:通过checked属性
 <input type="radio" name="sex" value="0" checked="checked" />女

3).
select :在option上通过selected属性
<select name="address">
        <option value="sz">深圳</option>
        <option value="bj">北京</option>
        <option value="sh" selected="selected">上海</option>
    </select><br/>
4).
textarea:直接在标签体中写	
自我介绍: <textarea rows="5" cols="20" name="introduce">哈哈哈</textarea><br/>


7.
HTML5中新增的type类型

值	描述
color	定义拾色器
date	定义日期字段(带有calendar控件)
email	定义用于e-mail地址的文本字段,如果输入不正确的邮箱地址有验证的功能
number	定义带有spinner控件的数字字段
range	定义带有slider控件的数字字段
search	定于用于搜索的文本字段,当输入内容的时候,搜索框后边会自动出现一个小X
	点击这个小X,可以消除输入的内容.
tel	定义用于电话号码的文本字段,在手机上操作会出现输入数字的键盘
url	定义用于URL的文本字段,在手机上操作会出现输入网址的键盘

8.
placeholder:
<form action="demo_form.asp" method="get">
  <input type="search" name="user_search" placeholder="Search W3School" />
  <input type="submit" />
</form>
placeholder 属性适用于以下的 <input> 类型：text, search, url, telephone, email 以及 password。

9.
div是html里面的一个标签<div></div> .  没有特定的含义, 作为容器. 一般用于配合css完成网页的基本布局,
span也是一个标签,没有特定含义,一般作为文本容器 

div是块级元素(eg:标题,p)会独占一行,span是行内元素(img,i,b...)不会独占一行
div中可以嵌套其它所有的标签(除了body,html,head), span标签中只能嵌套文本/图片/超链接

10.
- 层叠样式表 
  - 层叠: 样式的层层叠加(eg: 刷墙)
  - 样式表: 样式的集合, 说白了就是属性的集合
学习HTML的核心是标签,  学习CSS的核心是属性, 选择器

11.
语法:

{
	属性:属性值 属性值;
	属性:属性值 属性值
}

- 属性和属性值用:连接
- 如果有多个属性值用空格隔开
- 如果有多个属性,属性和属性之间用;隔开  最后一个;可以不写

12.

(一)通过标签的style属性来结合【了解】
<!--通过style属性-->
<p style="属性名称:属性值;..."></p>



(二)<head>
	<style type="text/css">
        标签名称{
            属性名称: 属性对应的值;
           	
        }
	</style>
</head>

注意点:
	1.style标签必须写在head标签的开始标签和结束标签之间(也就是必须和title标签是兄弟关系)
	2.style标签中的type属性其实可以不用写, 默认就是type="text/css"
	3.设置样式时必须按照固定的格式来设置. key: value; 其中:不能省略, 分号大多数情况下也不能省略

(三)
通过link标签结合【掌握】

1. 创建一个css文件(后缀是css)
2. 通过link标签引入

<head>
	<link rel="stylesheet" href="../../css/myCss.css" />
</head>

link标签属性:
	- href:css文件路径

14.基本选择器
css修饰页面,作用某个标签.CSS选择器就是控制html标签,说白了就是找到标签的

选择器分类		作用			语法		细节

标签选择器		通过标签名选择		标签{}
			同名的所有的标签

类选择器		通过calss属性的值选择			前提:先给标签进行分类
			元素			.类名{}		使用class属性分类.类名:不能以数字开头

ID选择器		通过属性ID选择元素	#ID{}		前提:先给标签指定属性ID,建议ID在同个网页中唯一,不要重复

通用选择器		选中整个网页中所有的元素  *{}

通用选择器 < 标签选择器 < 类选择器 < ID选择器

15:
扩展选择器

扩展选择器		格式			作用					语法符号
							
层级选择器		父选择器 子孙选择器{}	选择某个元素下面的所有子孙元素		空格

属性选择器		标签名[属性名]		 包含属性名即可
			标签名[属性名="属性值"]  属性名=属性值才可以
						 通过属性名和属性值选中符合条件的元素	[]中括号

并集选择器		选择器1,选择器2		同时使用2个选择题的和			,逗号

16.
伪类选择器

伪类选择器		格式			作用				语法
 
伪类选择器		链接:			元素在操作过程中不同状态
			a:link正常状态		呈现不同的样式			:冒号	
			a:visited访问过的
			a:hover 鼠标悬停
			a:active 正在激活
17.
公共属性

- name
  - 作为单选/复选分组
  - 作为key把数据提交. 如果想把数据提交, 【一定】要设置name属性
- value
  - 给按钮取名字
  - 作为value提交 ,  单选,复选框 要设置value的,  text, password 不需要设置


day22:

1.
setInterval(code,time)  按照指定的周期（以毫秒计）来调用函数或计算表达式
参数说明: code即执行的代码;  
方式一: 函数名 		setInterval(show,3000);
方式二:函数字符串	setInterval("show()",3000);
time:时间,单位毫秒

2.
- ECMAScript核心:  js基本语法,数据类型,语句,函数(方法)...
- BOM:定义了一组和浏览器相关的方法和接口.  说白了就是控制浏览器的
- DOM:定义了一组操作文档(HTML)的方法和接口.  操作HTML

3.
如果需在 HTML 页面中插入 JavaScript，请使用 <script> 标签。<script> 和 </script> 会告诉 JavaScript 在何处开始和结束。
内嵌式:
<script>
	alert("哈哈哈");
</script>
外链式:
<script type="text/javascript" src="../../js/test.js" >
	//js代码不会执行(不要写代码)
</script>

4.
1.var可以省略不写,建议保留
2.最后一个分号可以省略,建议保留
3.同时定义多个变量可以用","隔开，公用一个‘var’关键字. var c = 45,d='qwe',f='68';

5.
typeof操作符

- 作用： 用来判断变量是什么类型
- 写法：typeof(变量名) 或 typeof 变量名
- null与undefined的区别：
  	null: 对象类型，已经知道了数据类型，但对象为空。
  	undefined：未定义的类型，并不知道是什么数据类型。

6.
五种原始数据类型:
number  数值型:整数\浮点
boolean 布尔类型
字符串	包含字符和字符串,即可以使用双引号又可以使用单引号
object	对象类型
undefined 未定义类型,一个变量没有赋值之前的状态

7.
字符串转换成数字类型 

- 全局函数(方法)，就是可以在JS中任何的地方直接使用的函数，不用导入对象。不属于任何一个对象
parseInt()
parseFloat()
isNaN() 转换前判断被转换的字符串是否是一个数字 非数字true isNaN=is not a number

8.
JS常用的小功能

- alert(): 弹出警示框
- console.log(): 向控制台打印日志 
document.writte(); 文档打印. 向页面输出内容

9.
有名函数:
语法:
function 函数名(参数列表){
  函数体
}

注意:
	1.不管有没有返回值,函数格式是一样的 function 函数名(参数列表){函数体}
	2.如果有参数,参数不需要加var关键字(不需要加类型)
	3. JS中函数是没有重载的,后面的会把前面给覆盖掉

10.
点击事件:
- 方式1:通过标签的事件属性绑定 

    <input  type="button" onclick="函数名(参数列表)" />

- 方式2:派发事件(注意:页面加载成功之后才可以派发)

    元素对象.onclick=function(){};  元素对象可以通过:document.getElementById("id值")来获得;
11.
需要重点掌握的事件

- onclick: 点击(单击)
- onsubmit: 表单提交
- onfocus: 获得焦点;  
- onblur: 失去焦点

onload: 等页面加载完成 (可以不使用, 直接把script写在下面)
onchange 内容改变

12.
window: 窗体对象

  方法             	作用                               
  alert()        	显示带有一段消息和一个确认按钮的警告框              
  confirm()      	显示带有一段消息以及确认按钮和取消按钮的对话框          
  setInterval()  	按照指定的周期（以毫秒计）来调用函数或计算表达式         
  setTimeout()   	在指定的毫秒数后调用函数或计算表达式               
  clearInterval()	取消由 setInterval() 设置的 Interval()。
  clearTimeout() 	取消由 setTimeout() 方法设置的 timeout。  

13.
navigator:浏览器导航对象【了解】

  属性        	作用           
  appName   	返回浏览器的名称     
  appVersion	返回浏览器的平台和版本信息

2.3,screen:屏幕对象【了解】

  方法    	作用        
  width 	返回显示器屏幕的宽度
  height	返回显示屏幕的高度 

2.4,history:历史对象【了解】

  方法       	作用                    
  back()   	加载 history 列表中的前一个 URL
  forword()	加载 history 列表中的下一个 URL
  go()     	加载 history 列表中的某个具体页面 

2.5,location:当前路径信息

  属性  	作用                  
  host	设置或返回主机名和当前 URL 的端口号
  href	设置或返回完整的 URL        
  port	设置或返回当前 URL 的端口号    

location.href;  获得路径

location.href = "http://www.baidu.com";  设置路径,跳转到百度页面

14.








day25:
1.
反射是一种机制/功能，利用该机制/功能可以在==程序运行==过程中对类进行解剖并操作类中的构造方法，成员方法，成员属性。
反射乃框架之灵魂
反射就是把Java的各种成分(字段,方法)映射成相应的Java类.  

2.
1. 反射第一步: 获得字节码, 应该是获得字节码对象
2. 获得字节码对象三种方式
   - 对象.getClass();
   - 类.class()
   - Class.forName("类的全限定名");
3. 字节码对象操作
   - getName();  获得类的全限定名
   - clzz.newInstance();  依赖无参构造方法创建对象
3.
clazz.getDeclaredConstructors();  //获得所有的构造方法(包含私有的)
clazz.getConstructor(Class... paramType); //获得特定的构造方法
constructor.newInstance(Object...params);// 根据构造方法创建对象

4.
1. Field[] getFields()
获取所有的public修饰的属性对象，返回数组

2. Field[] getDeclaredFields()
获取所有的属性对象，包括private修饰的，返回数组

3. Field getField(String name)
根据属性名获得属性对象，只能获取public修饰的

4. Field getDeclaredField(String name)
根据属性名获得属性对象，包括private修饰的

5.
Field类中常用方法

    set(obj,value);通用方法都是给对象obj的属性设置使用
    get(obj); 通用方法是获取对象obj对应的属性值的
    void setAccessible(true);暴力反射，设置为可以直接访问私有类型的属性
6.
1. Method[] getMethods()
获取所有的public修饰的成员方法，包括父类中

2. Method[] getDeclaredMethods()
获取当前类中所有的方法，包含私有的，不包括父类中

3. Method getMethod("方法名", 方法的参数类型... 类型)
根据方法名和参数类型获得一个方法对象，只能是获取public修饰的

4. Method getDeclaredMethod("方法名", 方法的参数类型... 类型)
根据方法名和参数类型获得一个方法对象，包括private修饰的

Method类中常用方法

    1. Object invoke(Object obj, Object... args)
    根据参数args调用对象obj的该成员方法
    如果obj=null，则表示该方法是静态方法
    
    2. void setAccessible(true)
    暴力反射，设置为可以直接调用私有修饰的成员方法
7.
BeanUtils是Apache Commons组件的成员之一，主要用于简化JavaBean封装数据的操作。常用的操作有以下三个：

1. 对JavaBean的属性进行赋值和取值。
2. 将一个JavaBean所有属性赋值给另一个JavaBean对象中。 (前提是属性一致)

1. 将一个Map集合的数据封装到一个JavaBean对象中。(web阶段, 特别是注册里面)

8.
JavaBean就是一个类,用来封装数据的, 但该类需要满足以下四个条件：

1. 类必须使用public修饰。
2. 提供无参数的构造器。(一旦写了有参构造方法, 一定要把无参构造方法写进去)
3. 提供公共get和set方法访问属性。
4. 实现序列化接口(一般不写)

JavaBean的两个重要概念

	字段：就是成员变量，字段名就是成员变量名。

	属性：属性名通过setter/getter方法去掉set/get前缀，首字母小写获得。

	一般情况下, 习惯通过IDEA生成, 把字段和属性设置成一样的
9.
BeanUtils常见的方法

- public static void populate(Object bean, Map<String, ? extends Object> properties); 将一个Map集合中的数据封装到指定对象bean中(注意：对象bean的属性名和Map集合中键要相同)

2.2使用步骤

- 导入jar
- 调用BeanUtils.populate(obj,map)方法

10.
.自定义注解

1. 语法

    @interface 注解{
    	属性
    }
    

1. 自定义注解里面一旦有了属性, 属性就需要赋值
2. 属性赋值的特殊情况
   - 属性类型是数组, 如果只有一个值 {}可以省略
   - 只有一个属性需要赋值, 并且属性名是value , value可以省略
   - 属性有默认值
3. 元注解
4. 注解解析

后面的话, 很少使用自定义注解的. 后面学web. 学框架 你会@xxx就OK了





day27:
1.
静态资源:
所有用户访问后,得到的结果都是一样的,称为静态资源
动态资源:
每个用户访问相同的资源,得到的结果可能不一样.

2.
tomcat与nginx的区别

等我们讲nginx时候, 再比较

- 设计目的 
  	Tomcat是一个免费的开源的Servlet(动态资源)容器，实现了JAVAEE规范，遵循http协议的的服务器
  	Nginx是一款轻量级的电子邮件（电子邮件遵循IMAP/POP3协议）代理服务器，后来又发展成可以部署静态应用程序和进行反向代理的服务器
- 存放内容
  	tomcat可以存放静态和动态资源
  	nginx可以存放静态资源
- 应用场景
  	tomcat用来开发和测试javaweb应用程序
  	nginx用来做负载均衡服务器
3.
WEB-INF 里面的资源 受保护的, 不能直接被外界(浏览器)访问, 但是可以通过程序访问

4.
- 请求方式(8种,put,delete等)【面试】
  	GET:明文传输, 不安全,参数跟在请求路径后面,对请求参数大小有限制, 
  	POST: 暗文传输,安全一些,请求参数在请求体里,对请求参数大小没有有限制,
- URI:统一资源标识符（即：去掉协议和IP地址部分）

5.
1. 响应行(协议版本 ==响应状态码==  响应的描述)
   - 200 成功
   - 302 重定向
   - 304 读取缓存
   - 404 客户端错误(一般路径写错了)
   - 500 服务器错误
2. 响应头: 服务器告诉浏览器去做什么, 指示浏览器做什么
   - Location: 设置重定向的地址
   - Content-Type: 服务器告诉浏览器传输内容的类型
   - Refresh: 服务器指示浏览器定时跳转(刷新)
   - Content-Disposition: 服务器告诉浏览器去下载
3. 响应体: 页面展示的内容

6.
- Servlet对象是由服务器创建
- request与response对象也是由tomcat服务器创建
- service()方法也是服务器调用的


day28:

一.
1. Servlet生命周期方法
   - init() 初始化
   - service() 服务
   - distory() 销毁
2. Servlet生命周期描述
   	默认情况下, 第一次请求的时候, 会调用init()方法 进行初始化【调用一次】
   	任何一次请求, 都会调用service()方法处理这个请求
   	服务器正常关闭/项目从服务器移除, 会调用destory()方法进行销毁
二.
ServletContext: 是一个对象, 上下文对象. 

	服务器为每一个应用(项目)都创建了一个ServletContext对象。 ServletContext属于整个应用的，不局限于某个Servlet。 全局管理者. 
三.
作为域对象存取数据,让Servlet共享

获得文件mime类型（文件上传和下载） 

获得全局初始化参数

获取web资源路径  

四.


1. API
   - String  getRealPath(String path);根据资源名称得到资源的绝对路径.
   - getResourceAsStream(String path) ;返回制定路径文件的流

1. 作为域对象存取数据
   - setAttribute(String name, Object obj)  存
   - getAttribute(String name) 取
   - removeAttribute(String name) 移除
2. 获得文件mime类型(文件下载会使用)
   - getMineType(String 文件名);
3. 获得全局初始化参数(Spring里面可能会遇到)
   - 先在web.xml 配置
   - 调用 getInitParameter(String name)
4. 获取web资源路径【已经到了web目录了】
   - String  getRealPath(String path);根据资源名称得到资源的绝对路径.
   - getResourceAsStream(String path) ;返回制定路径文件的流


五.
常用的响应头 

		Refresh:定时跳转 (eg:服务器告诉浏览器5s之后跳转到百度)

		Location:重定向地址(eg: 服务器告诉浏览器跳转到xxx)

		Content-Disposition: 告诉浏览器下载

		Content-Type：设置响应内容的MIME类型(服务器告诉浏览器内容的类型)

response.setHeader("refresh","秒数;url=跳转的路径");

六.
1. 操作响应体的API:  response.setHeader(String key,String value);
2. 定时刷新  Refresh
3. 重定向  response.sendRedirect("重定向的路径")
   - 重定向两次请求
   - 重定向的地址栏路径改变
   - 重定向的路径写绝对路径, 带域名/ip地址的(如果路径在同一个项目里面,域名/ip地址可以省略的)
   - 重定向的路径可以写项目内部的, 也可以写项目外部的(eg: 百度)
七.
注解servlet的路径,多个:@WebServlet(urlPatterns = {"/demo","/demo01"})

day29:

一.
获取客户机信息(操作请求行)

	请求方式  请求路径(URI)  协议版本

	POST	/day17Request/WEB01/register.htm?username=zs&password=123456   HTTP/1.1	

- getMethod();获取请求方式  
- getRemoteAddr() ；获取客户机的IP地址
- getContextPath();获得当前应用工程名(部署的路径); 
- getRequestURI();获得请求地址，不带主机名    
- getRequestURL()；获得请求地址，带主机名 
- getServerPort()；获得服务端的端口     
- getQueryString()；获的请求参数(get请求的,URL的?后面的. eg:username=zs&password=12345)

3.2.获得请求头信息(操作请求头)

二.

tring getParameter(String name)

获得指定参数名对应的值。如果没有则返回null，如果有多个获得第一个。  例如：username=jack

String[] getParameterValues(String name)

获得指定参数名对应的所有的值。此方法专业为复选框提供的。  例如：hobby=抽烟&hobby=喝酒&hobby=敲代码

Map<String,String[]> getParameterMap()

获得所有的请求参数。key为参数名,value为key对应的所有的值。

三.
1. get方式, 我们现在使用的tomcat>8.0了, 乱码tomcat已经处理好了
2. post方式, 就需要自己处理
void setCharacterEncoding(String env); //设置请求体的编码

四.
1. 获得请求参数
   - 获得一个值   request.getParameter(String name);
   - 获得多个值  requets.getParameterValues(String name);
   - 获得map     request.getParameterMap();   map的key是表单name, map的value是提交的数据
2. 把请求参数封装成Java对象
   - 如果参数个数不多, 直接获得 直接封装
   - 如果参数个数很多, 获得map, 再使用BeanUtils.populate()
3. 乱码
   - 为什么出现乱码?  编码和解码不一致, iso8859-1不支持中文
   - 请求(请求参数)乱码
     - get 方式请求,  不需要处理(tomcat>=8.0, 服务器已经处理好了)
     - post方式请求  request.setCharacterEncoding("utf-8")
   - 响应乱码  response.setContentType("text/html;charset=utf-8");


五.
ServletContext: 范围 整个应用(无论多少次请求,只要是这个应用里面的都是可以共享的)

	request范围: 一次请求有效  

	域对象是一个容器，这种容器主要用于Servlet与Servlet/JSP之间的数据传输使用的。

- Object getAttribute(String name) ;
- void setAttribute(String name,Object object)  ;
- void removeAttribute(String name)  ;

3.小结
1. 作为域对象存取数据
   - Object getAttribute(String name) ;  取
   - void setAttribute(String name,Object object)  ; 存
   - void removeAttribute(String name)  ; 移除
2. 范围: 一次请求有效.  转发有效, 重定向无效

六.
转发和重定向区别【面试】

1. 转发是一次请求, 重定向是二次请求
2. 转发只能转发到项目的内部资源, 重定向可以是项目的内部资源也可以外部资源
3. 转发的路径不写ip地址和项目名, 重定向的地址需要写ip地址和项目名(如果是同一个项目,ip可以省略)
4. 把数据存到request里面, 转发有效, 重定向无效







day30:

1.
Java server page(java服务器页面).  ==JSP本质就是Servlet==  
它和servle技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。JSP=html(js,css)+java+jsp特有的内容
2.
  类型              	翻译成Servlet对应的部分                     	注意         
  <%...%>:Java程序片段	翻译成Service()方法里面的内容, 局部的            	           
  <%=...%>:输出表达式  	翻译成Service()方法里面的内容,相当于调用out.print()	输出表达式不能以;结尾
  <%!...%>:声明成员变量 	翻译成Servlet类里面的内容                    	           

3.
JSP注释
		HTML源码中    翻译的servlet代码中
HTML 注释	存在		存在
java注释	不窜在		存在
jsp注释		不存在		不存在

4.cookie的分类
- 会话级别cookie
  在==默认的情况==下，当浏览器进程结束(浏览器关闭,会话结束)的时候，cookie就会消失。
- 持久性cookie
  	给cookie设置有效期.cookie.setMaxAge(int expiry)  :时间是秒
  		 -1：默认。代表Cookie数据存到浏览器关闭（保存在浏览器文件中）。
          正整数：以秒为单位保存数据有有效时间（把缓存数据保存到磁盘中）      
  		 0：代表删除Cookie.如果要删除Cookie要确保路径一致。 
5.
cookie设置有效路径

    setPath(String url) ;设置路径

	浏览器可以存储多个cookie，每一个cookie都有各自的路径(没有设置, 有一个默认的路径)。一个路径不存在重名的cookie, 如果路径和名字一样,后面的会把之前的给覆盖掉,不同路径下可以有重名的cookie 
6.
1. Cookie的类型
   - 会话级别: 会话结束(浏览器关闭) 就是消失
   - 持久级别: 可以设置有效的时长  cookie.setMaxAge(int 秒);
2. cookie有效路径  cookie.setPath(String path)  建议设置成当前的项目名路径;   ==setPath(request.getContextPath())==
   - 为了当前项目里面的资源可以使用cookie
   - 为了删除cookie
3. cookie的弊端 cookie的大小(个数和自身大小)和格式(只能存字符串)有限制,默认不支持中文,解决中文办法   

    URLEncode.encode(value,"utf-8");//存入的时候(先通过utf-8编码)
    URLDecode.decode（value，"utf-8"）;//取出 (通过utf-8解码)


7.
创建一个 cookie，cookie 是 servlet 发送到 Web 浏览器的少量信息，这些信息由浏览器保存，然后发送回服务器。cookie 的值可以唯一地标识客户端，因此 cookie 常用于会话管理。 
一个 cookie 拥有一个名称、一个值和一些可选属性，比如注释、路径和域限定符、最大生存时间和版本号。一些 Web 浏览器在处理可选属性方面存在 bug，
因此有节制地使用这些属性可提高 servlet 的互操作性。 

servlet 通过使用 HttpServletResponse#addCookie 方法将 cookie 发送到浏览器，该方法将字段添加到 HTTP 响应头，以便一次一个地将 cookie 发送到浏览器。
浏览器应该支持每台 Web 服务器有 20 个 cookie，总共有 300 个 cookie，并且可能将每个 cookie 的大小限定为 4 KB。 

浏览器通过向 HTTP 请求头添加字段将 cookie 返回给 servlet。可使用 HttpServletRequest#getCookies 方法从请求中获取 cookie。一些 cookie 可能有相同的名称，但却有不同的路径属性。

8.
session是服务器端的技术。服务器为每一个浏览器开辟一块内存空间，即session对象。由于session对象是每一个浏览器特有的，所有用户的记录可以存放在session对象中。
同时，每一个session对象都对应一个sessionId，服务器把sessionId写到cookie中，再次访问的时候，浏览器把sessionId带过来，找到对应的session对象

9.
cookie和Session的不同

- cookie是保存在浏览器端的，大小和个数都有限制。session是保存在服务器端的， 原则上大小是没有限制(实际开发里面也不会存很大大小), 安全一些。    
- cookie不支持中文，并且只能存储字符串；session可以存储基本数据类型，集合,对象等

10.
获得cookie中传递过来的SessionId(cookie)

	2、如果Cookie中没有sessionid,则创建session对象

	3、如果Cookie中有sessionid,找指定的session对象

		如果有sessionid并且session对象存在，则直接使用

		如果有sessionid，但session对象销毁了，则执行第二步
11.
1. session是服务器端的技术, 数据保存在服务器里面(内存)
2. session基于cookie的, 因为sessionId通过cookie保存的, 而这个sessionId是作为session唯一标识, 找到当前session的凭证
3. 只有当调用了request.getSession()方法 才会创建session

12.
Session的基本用法（作为域对象存取数据）

	范围: 会话(多次请求)   

- request.getSession(); 获得session(如果第一次调用的时候其实是创建session,第一次之后通过sessionId找到session进行使用)
- Object getAttribute(String name) ;获取值
- void setAttribute(String name, Object value) ;存储值
- void removeAttribute(String name)  ;移除

13.
- 如果是正常关闭服务器,
  把session(内存)序列化到服务器磁盘上,再次启动,把磁盘上的文件反序列化到内存里面
      序列化:对象变成字节序列(以文件形式存在的)的一个过程	 	 内存-->硬盘
      
      反序列化: 字节序列(以文件形式存在的)变成对象的一个过程     硬盘--->内存





day31:
1.
EL表达式用途:
1.获取数据. 获取的是==域对象==中存储的数据
2.EL执行运算

2.
Expression Language:表达式语言,  jsp2.0之后内置在jsp里面
目的：为了使JSP写起来更加简单, 取值(取的域对象里面存的值)更加简单。(代替脚本 <% %>)

3.
1. 获得简单类型    ${key}
2. 获得数组类型    ${key[下标]}
3. 获得List              ${key.get(下标)}
4. 获得map            ${key.get("键")}
5. 获得JavaBean    ${key.javaBean属性名}

4.
- 获取的是三个域范围的值，存入三个域中
- 能获取到则获取,获取不到返回" "字符串 ,不是返回null
- ${域中属性名}:依次从requestScope|sessionScope|applicationScope中查找指定的属性
  	若找到,立即返回,且结束该次查找
  	若找不到返回""
- 若属性名中出现了".""+""-"等特殊的符号的时候,快捷获取的方式不好使,必须使用以下方式:
  	${xxxScope["属性名"]}	

5.
empty

- 作用
  - 判断对象是否为null
  - 判断一个集合长度是否为0
  - 判断一个字符串是否为""
- 注意事项
  - 如果是集合,  满足 这个集合不为null并且集合长度不为0, 那么才不是empty

6.
JSTL（JSP Standard Tag Library，JSP标准标签库)是一个不断完善的开放源代码的JSP标签库，是由apache的jakarta小组来维护的。这个JSTL标签库没有集成到JSP的, 要使用的话, 需要导jar包.

7.
JSP + Servlet + JavaBean 称为MVC的开发模式.

	==MVC:开发模式==

	M：model 模型 （javaBean：封装数据）

	V：View 视图  （JSP：展示数据）

	C：controller 控制器 （Servlet：处理逻辑代码，做为控制器）
	
	



day 33:

1.
Filter：一个实现了特殊接口(Filter)的Java类. 实现对请求资源(jsp,servlet,html,)的过滤的功能.  
过滤器是一个运行在服务器的程序, ==优先于请求资源(Servlet或者jsp,html)之前执行==. 过滤器是javaweb技术中最为实用的技术.

2.
1. Filter是运行在服务器端的程序, 优先于请求资源(Servlet,JSP,HTML...)之前执行
2. 作用
   - 过滤目标资源
   - 处理乱码
   - 登录权限进行检查
   - 过滤敏感字符
3.
- 完全路径匹配, 以"/"开始 

    /demo01 ---> 过滤器只能拦截路径/demo01; 

- 目录匹配:以"/"开始 以 *结束 .   

    /* --->当前项目下的所有的路径都可以拦截;   /aa/*  ---> 可以拦截 /aa/bb, /aa/bb/cc

- 扩展名匹配:以"*"开始 例如: *.jsp  *.do   

    *.do--->可以拦截路径的后缀是 do的 ;  *.jsp--->拦截所有JSP


4.
FIlter的生命周期方法

- init(): 服务器启动的时候调用, 调用一次
- doFilter(): 任何一次请求都会调用(前提是路径相匹配), 调用n次
- destory(): 服务器正常关闭  调用一次

5.
- DispatcherType.REQUEST
  默认值,过滤从浏览器发送过来的请求和重定向  不过滤转发
- DispatcherType.FORWARD
  只过滤转发过来的请求  

6.
jquery:
html()设置或返回匹配的元素集合中的 HTML 内容。

获得内容 - text()、html() 以及 val()
三个简单实用的用于 DOM 操作的 jQuery 方法：

text() - 设置或返回所选元素的文本内容
html() - 设置或返回所选元素的内容（包括 HTML 标记）
val() - 设置或返回表单字段的值value


day34:jQuery基础






===第三部===







day37:

1.
mkdir –p app2/test  创建一个目录app2并且在app2目录中再创建一个test目录

2.
切换目录命令cd(change directory)

	cd app	切换到app目录

	cd ..         切换到上一层目录

	cd /          切换到系统根目录

	cd ~    	 切换到用户主目录(回到超级管理员的家)回到root目录

	cd -           切换到上一个所在目录(上一个操作的)(了解)
3.
ls		展示当前目录下资源（不包含隐藏的文件）(记住)

ls -a		显示当前目录的所有文件或目录（包含隐藏的文件）, 文件带点的是隐藏文件

ls -l  	展示所有文件(不包含隐藏文件)的详细信息,  可以简写成 ll

ll -h		在ll的基础上友好显示文件大小(记住)

ls -al	展示文件的详细信息（包含隐藏的文件）,可以简写成"ll -a"

ll -ah       展示文件的详细信息（包含隐藏的文件）,并友好显示文件大小

4.
创建某个目录: mkdir 目录名字

	循环创建目录: mkdir -p a目录/b目录

	删除目录:rmdir 目录的路径，注意:这个命令只能删除空目录

5.
cat 命令:一次性查看完整个文件，并且跳到最后

	more命令:可以进行分页查看文件，enter键就是向下查看一行、space键就是向下查看一页，这种查看方式可以显示查看的进度。想要退出查看:ctr + c

	less命令:也可以进行分页查看文件，但是它无法显示查看进度。想要退出查看:q

	tail命令:查看文件的末尾多少行  -f   tail -10 install.log

6.
1. mv 文件名 路径名 ， 将某个文件移动到指定目录
   1. mv  文件名 路径名/另外的文件名, 将某个文件移动到指定目录，并且进行重命名
   2. mv  目录名  另外一个目录名， 将某个目录移动到另外一个目录
   3. mv 文件名 另外一个文件名，给文件重命名

7.
cp(copy) 拷贝文件
cp 文件名   路径名:将某个文件拷贝到某个目录

1. cp 文件名   路径名/另一个文件名 : 将某个文件拷贝到某个目录，并且重命名
2. cp  文件名  另外一个文件名: 在当前目录下复制一个文件并且重命名
3. cp -r  目录名  另一个目录 : 将某一个目录拷贝到另外一个目录

8.
1. rm 文件名 删除某个文件，此时会询问你是否要删除
   参数f表示不询问，直接删除

     参数r表示递归删除，如果要删除非空目录，必须加上r参数

9.
- 打开文件:vi file  ,处在普通模式
- 普通模式下，不能编辑文件，要切换到编辑模式才能编辑
  - 按i,可以从普通模式进入编辑模式
  - 普通模式常用的快捷键
    - yy:复制当前行
    - p:粘贴
    - dd:删除当前行

- 在编辑模式下，只能编辑，不能保存和退出。要切换到"底行模式"才能保存和退出
  - 1.不能从编辑模式直接进入底行模式，只能从命令模式进入底行模式，所以在编辑模式下要先按"Esc"键进入普通模式。
  - 2.在普通模式下，按"shift+:"进入底行模式
- 在底行(命令)模式下，有如下命令行
  - 1.wq    保存并退出(一般情况下都是使用这个)
  - 2.q        退出(不保存)
  - 3.q!       强制退出(出异常了就可以使用强制退出)

10.
5.1打包压缩

压缩语法：tar    [参数]     打包压缩后的文件名     要打包压缩的文件，支持通配符*号

将多个文件打包并压缩成一个特定的文件



gz,zip等等压缩文件

参数解释：

1. -c  创建新的文件（打包压缩的必选项）
2. -x  取出文件中的内容（解包、解压的必选项）
3. -f   文件名由命令台设置（打包解包都需要的必选项）
4. -v  输出文件清单（可选项）
5. -z  自动识别压缩或解压（可选项），要加上z才压缩，不加则不压缩

eg:
tar   -cvf 	demo.tar   a.java  b.java  c.java 打包
或
tar   -zcvf		demo.tar.gz 	 ./*     将当前目录下的所有文件打包压缩成demo.tar.gz文件

11.
5.2解包解压(最重要)

解压语法：tar   [参数]    压缩文件

                   解压后的文件在当前目录中

解压语法：tar    [参数]    压缩文件   –C/usr/local

                   解压后的文件放入/usr/local目录中，注意-C是大写字母C，后面不用接空格符

将一个特定的文件解包成多个文件，放在指定的目录下

参数解释：

1. -c   创建新的文件（打包压缩的必选项）
2. -x   取出文件中的内容（解包解压的必选项）
3. -f   文件名由命令台设置（必选项）
4. -v   输出文件清单（可选项）
5. -z   自动识别压缩或解压（可选项），只有压缩包才能加z

eg:
tar  -xvf  demo.tar demo.tar 这个文件，解包里面的文件释放到当前目录下
tar  -zxvf  demo.tar.gz -C/usr/local	
                            demo.tar.gz这个压缩文件，解压里面的文件释放到/usr/local目录下
12.
ifconfig:查看当前网卡信息
ping:检查网络是否通畅, ctrl+c:退出

	halt:关机(不用)(Linux电脑不用关机)

	reboot:重启(一般也不用)

	ps -ef:查看所有进程(很重要)

	|:管道 前面的输出作为后面的输入-------->就是从|之前的命令查询到的结果中筛选出符合|之后的条件的内容

	grep:查找指定的内容,grep -i:忽略大小写

	kill -9 进程号(pid):杀死指定的进程(很重要)


13.
linux防火墙
1. 永久性生效

开启：chkconfig iptables on

关闭：chkconfig iptables off

2. 即时生效，重启后失效

开启：service iptables start

关闭：service iptables stop




day38:

1.
通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令。时间间隔的单位可以是分钟、小时、日、月、年及以上的任意组合。这个命令非常适合做周期性的工作，如：数据备份，程序自动运行。
命令：yum install crontabs   安装启动定时服务这个安装包

2.
1. 语法：service crond start      启动定时服务
2. 语法：service crond stop       停止定时服务
3. 语法：service crond restart   重新定时服务 
4. 语法：service crond reload   重新加载定时配置文件

3.
语法：crontab  [参数]	

参数解释：

1. -u user    给指定用户设置定时任务，如果不写的话，默认是给当前用户设置定时任务
2. -l               显示当前用户所有的定时任务
3. -e              编辑当前用户的定时任务，一行一个定时任务
4. -r               删除当前用户的定时任务

4.
当输入crontab -e后，会启动vi编辑器，来编写新的定时任务，一行写一个定时任务。

格式如下：

分   时    日    月     年    需要执行的命令
当保存并退出vi编辑器后，定时任务立刻生效。

等一分钟，显示一下当前用户下的定时任务，和执行的输出内容
其它示例：

30  21  *   *   *   date  >>   /mydate.txt 

每晚的21:30，将时间输出到/mydate.txt文件中 

10  10  1,10,20,30   *   *   date   >>   /mydate.txt 

每月1，10，20，30号，的10点10分，将时间输出到/mydate.txt文件中。 

5.
语法1 ：hostname

获取主机名

语法2：hostname 新主机名

修改主机名，但重启后无效

6.
ip地址配置:
进入CentOS，查看网络配置

    命令：ip addr
    或者:ipfconfig
命令：vi /etc/sysconfig/network-scripts/ifcfg-eth0
配置动态IP
将ONBOOT=no改为ONBOOT=yes 激活网卡
重启网络服务:
命令：service network restart

7.
在Linux中，/etc/hosts文件用于在通过主机名进行访问时做IP地址解析之用。
命令：vi  /etc/hosts

8.
service network status      查看指定服务的状态
service network stop        停止指定服务
service network start       启动指定服务
service network restart     重启指定服务
service --status-all        查看系统中所有的后台服务

9.
chkconfig   			   查看所有服务的自启配置
chkconfig network off      关掉指定服务的自动启动
chkconfig network on       开启指定服务的自动启动
10.
系统中网络进程端口的监听
命令：netstat -a

11.
添加用户

语法：useradd   -m   [-g   组名]   新用户名

语法：passwd   新用户名

参数解释：

1. -m           自动在/home目录了，建立用户家目录，家目录名字就是新用户名
2. -g  组名   指定新用户所在的组，如果不带"-g  组名"参数的话，会建立和新用户名同名的组


12.
修改用户

语法：usermod   -l   新登录名   原登录名

修改原登录名为新登录名，但所在组名不变

13.
查看某个用户所属的组名:groups 用户名

语法：groupadd  组名

语法：usermod   -g    组名   用户

将用户添加到组中

参数解释：

1. -g  修改用户所属的群组

usermod -a -G itheima tom  将用户添加到某个组，但是不从原组中移除

语法：gpasswd  -d  用户  组名

语法：groupmod  -n  新组名  原组名

将原组名修改为新组名

14.
sudo，可以理解为超级管理员执行的操作，通常是系统级别的指令。

用root编辑 vi /etc/sudoers

在文件的如下位置，为hadoop添加一行即可

root           ALL=(ALL)       ALL    

tom          ALL=(ALL)       ALL

然后，tom          用户就可以用sudo来执行系统级别的指令。



普通用户获得超管权限之后，要执行超管命令那么要在这个命令前加上sudo这个单词

[itheima@localhost ~]$ sudo useradd  -m  tom



- r-- r-- --- 

chmod命令修改权限

总共有10位，类似:d rwx r-x ---

第一位代表的是类型

前三位:当前用户的权限

中间三位:与当前用户同组的用户的权限

后三位:其它组的用户的权限

权限包含:读(r)、写(w)、执行(x)

r:可读

w:可写

x:可执行


15.
Linux中防火墙根据配置文件/etc/sysconfig/iptables来控制本机的“出、入”网络访问行为，其对行为的配置策略有四个策略表
命令：service iptables status
命令：service iptables stop
命令：service iptables start
service iptables restart
service iptables reload
命令：chkconfig iptables off


16.
Nginx是一种服务器软件，其最主要，最基本的功能是可以与服务器硬件结合，让程序员可以将程序发布在Nginx服务器上，让成千上万的用户可以浏览。

除此之外，Nginx还是一种高性能的HTTP和反向代理服务器，同时也是一个代理邮件服务器。也就是说，我们在Nginx上可以：

1. 可以发布网站(静态资源)
2. 可以实现负载均衡
3. 可以作为邮件服务器实现收发邮件等功能
4. 可以作为反向代理服务器



修改/etc/sysconfig/iptables文件(推荐使用)，修改之后要重新启动防火墙service iptables reload


进入nginx的sbin目录
cd /usr/local/nginx/sbin

在sbin目录下启动
./nginx

在sbin目录下停止
./nginx -s stop

在sbin目录下重新加载
./nginx -s reload


打开/usr/local/nginx/conf/nginx.conf文件，修改server段的内容：
server {
        listen       80;
        server_name  localhost;
        location / {
            root   /ly;
            index  index.html index.htm;
        }
    }
核心解释如下：
Nginx服务器监听localhost:80的请求，

root表示项目的根目录，这里指向/ly目录
index表示项目中的默认首页是index.html或者是index.htm，Nginx自动访问默认首页





day39:

1.
NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。
非关系型数据库与关系型数据库的区别:

1. 关系型数据库的数据是存储在硬盘中，而非关系型数据的数据是存储在内存中
2. 关系型数据库有固定的数据模型，也就是说事先要定义好表
3. 关系型数据库的表与表之间有关系:一对一、一对多、多对多
4. 非关系型数据库存储的数据结构非常简单，不能事先定义好表，都是以"键值对"类型的数据进行存储

2.
在大数据存取上具备关系型数据库无法比拟的性能优势，例如：
易扩展
大数据量，高性能
灵活的数据模型
高可用

3.
Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，
且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：

- 字符串类型 string(掌握)
- 散列类型 hash
- 列表类型 list
- 集合类型 set
- 有序集合类型 sortedset

4.
三级缓存：1.从互联网上直接获取数据   2. 将数据缓存到内存中   3. 将内存中的数据存储硬盘中

5.
关于key的定义，注意如下几点:

- key不要太长，最好不要超过1024个字节，这不仅会消耗内存还会降低查找效率 
- key不要太短，如果太短会降低key的可读性 
- 在项目中，key最好有一个统一的命名规范:"项目名_模块名_功能名"   "travel_user_name"

6.
字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型存入和获取的数据相同。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。

7.
字符串类型string常用命令:
set key value
get key
del key

8.
哈希类型hash常用命令:
- Redis操作hash类型的小结:
  1. 存储hash类型的数据的命令
     1. hset key 字段名 字段值
     2. hmset key 字段名1 字段值1 字段名2 字段值2...
  2. 获取hash类型数据中的字段的值
     1. hget key 字段名
     2. hmget key 字段名1 字段名2...
  3. 删除hash类型数据中的字段
     1. hdel key 字段名1 字段名2...
	 2. del key
9.
列表类型list

- lpush key values[value1 value2…]
  在指定的key所关联的list的头部插入所有的values，如果该key不存在，该命令在插入的之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据。插入成功，返回元素的个数。
- rpush key values[value1 value2…]
- lpop key
  返回并弹出指定的key关联的链表中的第一个元素，即头部元素。如果该key不存在，返回nil；若key存在，则返回链表的头部元素。
- rpop key
从尾部弹出元素。

10.
集合类型set的常用命令
向set中添加数据，如果该key的值已有则不会重复添加
- sadd key values[value1、value2…]

获取set中所有的成员
smembers key

删除set中指定的成员
srem key members[member1、member2…]

11.
keys *

获取所有与pattern匹配的key，返回所有与该key匹配的keys。*表示任意一个或多个字符，?表示任意一个字符

del key1 key2…

删除指定的key

exists key

判断该key是否存在，1代表存在，0代表不存在

type key

获取指定key的类型。该命令将以字符串的格式返回。	返回的字符串为string、list、set、hash，如果key不存在返回none

12.
6.1 Redis持久化概述

Redis的高性能是由于其将所有数据都存储在了内存中，为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步(备份)到硬盘中，这一过程就是持久化。Redis支持两种方式的持久化，一种是RDB方式，一种是AOF方式。可以单独使用其中一种或将二者结合使用。

- RDB持久化（默认支持，无需配置）
  该机制是指在指定的时间间隔内将内存中的数据集快照写入磁盘。
- AOF持久化
  该机制将以日志的形式记录服务器所处理的每一个写操作，在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。
- 无持久化
  我们可以通过配置的方式禁用Redis服务器的持久化功能，这样我们就可以将Redis视为一个功能加强版的memcached了。
- redis可以同时使用RDB和AOF
13.
将appendonly修改为yes，开启aof持久化机制，默认会在目录下产生一个appendonly.aof文件



./redis-server redis.windows.conf开启redis服务器才能使用aof持久化方式

AOF持久化时机
# appendfsync always
appendfsync everysec
# appendfsync no
关键字

持久化时机

解释

appendfsync

always

每执行一次更新命令，持久化一次

appendfsync

everysec

每秒钟持久化一次

appendfsync

no

不持久化


14.
 jedis常用API

jedis的API非常简单:每一句命令就对应一个方法，方法名和命令名是一样的

  方法                   	解释                                      
  new Jedis(host, port)	创建jedis对象，参数host是redis服务器地址，参数port是redis服务端口
  set(key,value)       	设置字符串类型的数据                              
  get(key)             	获得字符串类型的数据                              
  hset(key,field,value)	设置哈希类型的数据                               
  hget(key,field)      	获得哈希类型的数据                               
  lpush(key,values)    	从列表的左边添加数据                              
  rpush(keymvalues)    	从列表的右边添加数据                              
  lpop(key)            	列表左面弹栈                                  
  rpop(key)            	列表右面弹栈                                  
  del(key)             	删除指定的key                                
15.
我们在工作中，要存放的数据一般在JavaBean对象中，list集合中，map中-------->redis中
redis中一般只能存放字符串，那么我们可以将对象转换成json字符串，并且存放到redis中。
JedisPoolConfig config = new JedisPoolConfig();
JedisPool jedisPool = new JedisPool(config, "localhost", 6379);
jedis = jedisPool.getResource();


day40:
1.
maven的命令的总结

1. clean命令，可以清理项目，将编译后的文件清除掉
2. compile命令，它可以编译maven项目中的java文件(test不会编译)，执行compile，必然先会将项目清理
3. test命令，它会编译和运行项目中的单元测试用例
4. package命令，将项目进行打包。执行package命令必然会先进行编译
5. install命令，将项目打包并且安装到本地仓库。执行install命令必然先会进行打包



springMVC
day53:

1.
MVC模型:
1. MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。
2. Model：数据模型，JavaBean的类，用来进行数据封装。
3. View：指JSP、HTML用来展示数据给用户
4. Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。

2.
SpringMvc入门程序的步骤总结

1. 在web.xml中配置核心控制器
   1. 配置DispatcherServlet
   2. 配置初始化参数contextConfigLocation,指定参数值为要加载的spring配置文件的类路径
   3. 通过load-on-startup标签，配置DispatcherServlet在服务器启动的时候加载
2. 创建一个springmvc的配置文件
   1. 开启包扫描
   2. 运行springmvc的注解
   3. 配置视图解析器
3. 创建一个控制器
   1. 给控制器上添加Controller注解
   2. 给要访问的控制器的方法上添加RequestMapping注解用于指定映射路径

3.
入参参数总结:

  1. 提交表单的name和参数的名称是相同的
  2. 如果接收JavaBean则必须和JavaBean的属性名相同
  3. 区分大小写
  4. 如果将参数封装到Map或者是List中，必须在方法的参数前添加@RequestParam注解
  
4.
public String useRequestParam(@RequestParam(value = "username",required = false) String name){
        //使用RequestParam注解指定要获取的请求参数的参数名
        //RequestParam注解中有一个required属性，表示是否一定要有这个参数，默认required为true
        System.out.println(name);
        return "success";
    }
 



===第四部===

重点:

==一:MAP==
遍历的方法:get() entrySet() values() keySet()
entrySet.getKey(),entrySet.getValue()

MAP集合特点:
1.键唯一        
为什么唯一?hashMap的数据结构是哈希表,哈希表的结构是:数组+链表. 通过哈希表的结构配合对象的hashCode和equals配合使用,建议:如果键的位置存储的是自定义类型,不要忘记重写hashCode和equals方法,否则不能去重.  应用场景:统计商品出现的次数map.containsKey()
2.无序


hashTable是jdk1.0后出现的不允许存储null键和null值,是同步的(线程安全),效率低
hashMap是jdk1.2后出现的允许存储null键和null值,是不同步的(线程不安全),效率高

JDK1.8版本后,某一个索引节点的数量下达到一定程度的时候,原本链表的结构改成二叉树结构,从而提升查询的效率.


==二.虚拟机==JVM
java虚拟机内存划分:
栈内存: 方法运行时进入的内存,里面还会存储程序的局部变量
堆内存: new出来的数据都不会进入堆内存,堆内存中的数据都有默认初始化值,对象是null,整数是0,还有空间存储成员方法的引用地址(其实就是成员变量和成员方法地址两个)
方法区: 字节码文件加载时所进入的内存,(静态区和非静态去区,静态区变量会首先赋值null,然后覆盖,非静态区不)
本地方法区: 这块内存空间主要调用的是操作系统相关的资源
寄存器: 交给cpu使用

线程内存空间:
1.每一个线程都有一个独立的栈内存空间
2.堆内存中的数据是被多个线程所共享


==三.异常处理机制==

异常分类:编译异常,运行异常
Throwable(最顶层类)
	Error 严重性错误
	Exception
		RuntimeException(运行时异常) 例如:数组越界异常
		!RuntimeException(编译时异常) 例如:文件找不到异常

异常的产生原理:
java对异常默认的处理方式抛给上一级,抛出之前会根据错误产生的异常类,创建出该类的对象,底层并通过throw关键字,将异常抛给上一级,不断向上抛出,直到抛给jvm虚拟机.jvm拿到问题之后,就会将错误的原因和所在的位置,打印到控制台.

异常处理方式:
1.问题可以自己处理的:
try..catch 自己将问题处理掉,不会影响后续代码的执行
2.问题自己处理不掉的:
throws抛出处理 ,强制终止程序,将异常展示到控制台
	throw:将异常抛给调用者
	throws:仅仅是对方法进行声明,告诉调用者此方法存在异常
如果用throw抛出异常,方法上必须用throws声明异常,告知调用者此方法存在异常.细节:如果抛出的异常时RuntimeException,则方法上无须throws声明.

spring框架的事务默认是RuntimeException才进行回滚.修改:@Transactional(rollbackFor={Exception.class})

自定义异常类:写一个类继承RuntimeException或者Exception



==四 线程==
start()是个native方法
创建线程的四种方式:

1.继承Thread类,重写run方法(代码简单,无法继承别的类)
2.实现Runnable接口(优点,能继承其他类,统一实现该接口的实例可以共享资源,缺点代码复杂)(除了call替换run,多余一步new FutureTask<object>(上面new的对象))
3.实现Callable接口(和runnable接口方式基本相同,callable的call()方法有返回值,而runnable的run()方法无返回值)
4.线程池(自动化装配,易于管理,循环利用)

Lock接口和比synchronized快的优势是什么?
1.lock中的方法:
	lock():加锁
	unlock():释放锁
2.可以方便的实现公平锁(先来先得,先进先出)	

synchronized只支持非公平锁

==五 垃圾回收机制==

1.什么样的对象会被当做垃圾回收?
当一个对象的引用(地址)没有变量名去记录的时候,该对象就会成为垃圾对象,并在垃圾回收器空闲的时候对其进行清扫.eg:Student s= new Student(); s=null;  回收new student()
2.如何校验对象是否被回收?
可以重写object类中的finalize方法,这个方法在垃圾回收器执行的时候,被回收器自动调用执行.
3.怎样溶质垃圾回收器回收对象?
可以调用system类的静态方法gc(),通知垃圾回收器去清理垃圾.eg:System.gc()

扩展:如何判断哪些对象需要回收呢?
1.引用计数法:引用+1,不引用-1,直到0清理,最大的问题是循环的时候不能正确的计数,不能正确的找到垃圾对象
2.根搜索方法:

应用场景:1.尽量不要创建很大的对象2.不要频繁的new生命周期很短的对象

==六 hashCode()和equals()方法的区别==
如果类中不重写此方法:
hashCode():属于本地方法,返回的是对象的地址值
equals():用来比较两个对象的地址值是否相等

如果类中重写此方法:
hashCode():返回的是根据对象的成员变量,计算的一个整数
equals():比较的是两个对象中成员信息是否相同

==七 String StringBuffer  StringBuilder的区别==
string和stringbuilder本质区别是?
string是一个不可改变的字符序列 
stringbuilder是一个可以改变的字符序列.

常见字符串拼接选择StringBuilder,因为效率更高,快.append  string用+拼接很慢,每次都会产生一个新的字符串,其实用的stringbuilder的tostring方法拼接

StringBuilder和Stringbuffer方法都完全相同
stringbuilder是jdk1.5版本后出现的,效率高,线程不安全
StringBuffer是jdk1.0版本后出现的,效率低(同步)线程安全

==八 是否可以从static方法内部发出对非static方法的调用==
static针对的是类,修饰类,成员变量,成员方法,不能修饰局部变量
static特点:
1.静态方法和变量,可以通过类名直接调用
2.静态成员优先于对象存在
3.静态成员被所在类的对象共享
4.静态成员随着类的加载而加载
注意:先进内存的不能调用后进内存的

static访问特点:
静态方法只能调用静态成员(和静态方法)
非静态方法可以调用任意成员

非静态方法属于对象的方法,类是优于对象而存在,静态方法随类的加载而加载.静态方法在内存时候,非静态方法不存在,静态方法调用不了非静态方法,先进内存的不能调用后进内存的.静态方法里不能用this

私有方法和静态方法不能被重写.private和static修饰的方法

抽象方法不能被static关键字修饰

非静态内部类与静态内部类的区别?
成员变量的区别:
	静态内部类:可以定义静态和非静态的成员变量
	非静态内部类:只能定义非静态成员变量
成员方法区别:
	静态内部类:可以定义静态方法和非静态方法
	非静态内部类:只能定义非静态方法
非静态方法访问区别:
	静态内部类:可以方法内部的静态和非静态成员,单只能访问外部类的静态成员
	非静态内部类:可以访问内部的非静态成员,外部的静态和非静态成员
	
静态代码块的特点与作用:
随着类的加载而加载,优于构造方法执行,并且只执行一次


static修饰利弊:
有利:
1.静态方法被所在类的所有对象共享,没有必要所有对象存储一份,节省空间
2.可以通过类名调用,方便使用
弊端:
1.静态方法随着类的加载而加载,随着类的消失而消失,生命周期较长
2.访问出现了局限性,只能访问静态

==九 java中wait()和sleep()的区别==
wait和sleep的基本使用:
wait:此方法来自于object类,必须由锁对象进行调用(同步方法的锁对象默认就是当前字节码对象),锁对象必须存在同步中 public static synchronized void xx(){}
sleep:此方法来自于Thread类,是Thread类的静态方法,可以类名点调用.(让当前程序休眠xx毫秒,休眠后继续执行)

wait方法:如果使用的是空参数无线等待,就必须由一个notify方法对其进行唤醒.(唤醒别人)

注意:
wait()等待的时候会释放锁对象,不然别的线程拿不到锁,不能执行,不能唤醒它
sleep()在休眠的时候不会释放锁对象

扩展
三个线程以及以上的时候:
if(flag=1)换成while(falge=1)
notify方法效果:随机唤醒单个线程
notifyAll:唤醒所有等待的线程

==十 String s=new String(xyz)创建了几个StringObject?是否可以继承String类==
String类被final修饰,不能被继承
字符串存在常量池中:
1.如果stirng常量池中,已经创建了"xyz,则不会继续创建,此时只创建一个对象new string("xyz")
2.如果string常量池中,没有创建"xyz",则会创建两个对象,一个对象的值是"xyz",一个对象是new string("xyz")

contains方法,连续包含字符串
equalsIgnoreCase忽略大小写
split(string regex)参数是一个正则表达式,如果穿入的是"."需要写成"\\.","+"需要写成"\\+",因为.或者+在正则中是有特殊含义

==十一多线程中解决同步问题的方式==
解决问题的方式:
1.同步代码块方式:eg:synchronized(this){}
2.同步方法方式:eg:synchronized修饰方法
3.Lock锁方式:Lock l = new ReentrantLock(); l.lock;finally{l.unlock}; 
应用场景:多线程卖票,卖到-1,或者重复卖

单例设计模式中的懒汉式和饿汉式的区别?
懒汉模式在类的加载的时候不被初始化,懒汉模式在创建对象时,不加上synchronized,导致对象的访问不是线程安全的.
饿汉模式在类加载的时候就完成了初始化,但是加载比较慢,获取对象比较快,线程是安全的,饿汉式在虚拟机启动的时候就会创建.

==十二 cookie和session的区别
1.cookie数据存放在客户端浏览器上,session数据放在服务器上
2.很多浏览器都限制一个站点最多保存20个cookie,单个cookie保存的数据不能超过4k
3.cookie并不是很安全.别人的分析存放在本地的cookie并进行cookie欺骗,考虑到安全应该使用session
4.可以考虑将登陆等重要信息存放在session,其他信息如果需要保留,可以放在cookie中
5.session会在一定时间内保存在服务器上(默认半小时),当访问增多,会比较占用服务器的性能,考虑到减轻服务器性能方面,应当把不是用户敏感信息保存到cookie
6.session会在浏览器关闭或者一段时间内销毁,也可以通过setManxInactiveInterval(int)方法进行设置,或是通过invalidate()方法强制结束当前会话,cookie可以通过setMaxAge(int)方法设置缓存在客户端的时间
7.一般情况下,session生成sessionid都是保存在cookie.
总结:cookie:在客户端保存数据,不安全,只能保存字符串,且是少量数据
	session:在服务器端保存数据,安全.可以保存对象数据,数据无限制

==十三 spring如何管理事务,事务管理机制?以及隔离级别==
隔离级别:
脏读(read uncommitted):一个事务读到另外一个事务还没有提交的数据
不可重复读(read committed):一个事务读到另一个事务已经提交的update的数据,导致在当前的事务中多次查询的结果不一致(避免脏读,不可重复读和虚读有可能发生) oracle默认级别
虚读/幻读(repeatable read):一个事务读到另一个事务已经提交的insert的数据,导致在当前的事务中多次的查询结果不一致(避免脏读,不可重复读,但是虚读有可能发生)
serializable:串行化的,避免脏读,不可重复读,虚读的发生

级别越高,约安全,效率越低

声明式事务和编程式事务

==十四 springAOP==
Spring AOP的实现原理？
考察目标：
SpringAOP的面向切面编程，是面向对象编程的一种补充，用于处理系统中分布的各个模块的横切关注点，比如说事务管理、日志、缓存等。它是使用动态代理实现的，在内存中临时为增强某个方法生成一个AOP对象，这个对象包含目标对象的所有方法，在特定的切入点做了增强处理，并回调原来的方法。
核心问题讲解Spring AOP的动态代理主要有两种方式实现，JDK动态代理和cglib动态代理。JDK动态代理通过反射来接收被代理的类，但是被代理的类必须实现接口，核心是InvocationHandler和Proxy类。cglib动态代理的类一般是没有实现接口的类，cglib是一个代码生成的类库，可以在运行时动态生成某个类的子类，所固以，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为fimal，那么它是无法使用CGLIB做动态代理的。

做动态代理的。
问题扩展:AOP能做什么：1、降低模块之间的耦合度2、使系统容易扩展3、避免修改业务代码，避免引入重复代码，更好的代码复用AOP怎么用：
前置通知：某方法调用之前发出通知。
后置通知：某方法完成之后发出通知
返回后通知：方法正常返回后，调用通知。在方法调用后，正常退出发出通知
异常通知：抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。在方法调用时，异常退出发出通知
环绕通知：通知包裹在被通知的方法的周围知。

==十五 spring用到哪些设计模式==
1.工厂模式
这个很明显，在各种BeanFacfory以及ApplicationContext创建中都用到
了。
2.模板模式
这个也很明显，在各种BeanFactory 以及ApplicationContext实现中也都  eg:httpservlet 里面根据请求选择doget  dopost方法
用到了。
3.代理模式
在Aop实现中用到了JDK的动态代理。
4.单例模式这个比如在创建bean的时候。
5.策略模式在spring中，我们可以使用JdbcTemplate实现对数据库的CRUD操作，而在查询时我们可能会用到Rowlapper接口以及spring提供的一个BeanPropertyRowlapper的实现类。Rowlapper接口就是规范，而我们根据实际业务需求编写的每个实现类，都是一个达成目标的策略。
6.观察者模式spring在javaEE应用中创建的WebApplicationContext时，是通过一个ContextLoaderListener监听器实现的。监听器就是观察者模式的具体体现。
7.适配器模式在spring-framework中提供了spring myc的开发包。我们在用springmyc中，它实现控制器方式有很多种。例如我们常用的使用@Controller注解，

==十六 spring和springMVC常用注解
@Component用于标记在一个类似，表示当前类是spring的一个组件，会进入ioc容器。它有三个衍生注解：@Controller@Service@Repositorya@Controller用于标记在一个类上，代表这个类是控制层组件。
@Controller用于标记在一个类上，代表这个类是控制层组件。
@Service用于标记在一个类上，代表这个类是业务层组件。
@Repository用于标记在一个类上，代表这个类是数据访问层组件。
@RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
@RequestParam用于将指定的请求参数赋值给方法中的形参。
@PathVariable可以获取URL中的动态参数。
@RequestBody用于读取Request请求的body部分数据。
@ResponseBody.用于将Controller的方法返回的对象，用流响应给客户端@RestController=@ Controller+@ResponseBody，用于标记在一个类上。
@Transactional写在类上用于指定当前类中的方法支持事务，写在方法上表示当前的方法支持事务。

springMVC 前端控制器DispatherServlet 处理映射器HandlerMapping 处理器Handler(controller) 处理器适配器HandlerAdapter  viewResolver视图解析器

==十六 ajax==
async:false /默认设置为true，所有请求均为异步请求。



==十七 两种动态代理的区别==

动态代理：1特点：字节码随用随创建，随用随加载。作用:不修改源码的基础上,对已有的方法进行增强.
分类：
基于接口的动态代理基于子类的动态代理
基于接口的动态代理：
要求：被代理类最少实现一个接口提供者：JDK官方涉及类：Proxy创建代理对象的方法：newProxyInstance方法中的参数：
ClassLoader：类加载器。
负责加载代理对象的字节码。


==十八 JSP和servlet的区别和联系
JSP的执行原理：
翻译-->编译-->执行isp翻译java编译classservlet：服务器端的小应用程序。适合编写java逻辑代码。
jsp：适合编写输出动态内容，但不适合编写java逻辑。
问题扩展一般情况，servlet是在被请求的时候才去创建的，它提供了生命周期的方法：实例化，初始化，服务和销毁。
比如我们可以在初始化方法设置一些初始数据等。使用servlet时，一般都是继承httpServlet，然后分别实现doGet或者doPost方法，但是在这里面要注意的是，这servlet并不是线程安全的，多线程单实例执行的，当并发访问同一个资源的话，就有可能引发线程安全问题，不要写全局变量.

==十九 ajax书写以及内部的主要参数有哪些
主要参数：
1.url：要求为string类型的参数，发送请求的地址。
2.Data：要求为object 或stirng类型，发送到服务器的数据。
3.Type：要求为Stirng类型，请求方式 post或get。
4.Datalype：要求为String类型，预期服务器返回的数据类型。
5.Timeout：要求为number类型，设置请求超时时间（毫秒）。
6.Async；要求为boolean类型，异步为true（默认），同步为false。
7.Cache：要求为boolean类型，默认为true，是否从浏览器缓存中加载信息。
8.Beforesend：要快为function类型的参数。例如添加自定义HTTP头
问题扩展ajax的优缺点？
优点：减轻服务器的负担，按需取数据，最大程度的减少冗余请求，局部刷新页面，减少用户心理和实际的等待时间，带来更好的用户体验。
缺点：aiax大量的使用了iavascript和aiax引擎，这些取决于浏览器的支持，在编写的时候考虑对浏览器的兼容性。AJAX只是局部刷新，所以页面的后退按钮是没有用的。


== springboot和springcloud
Spring Boot是Spring的一套快速配置脚手架，对第三方技术进行了很好的封装和整合，提供了大量第三方接口；可以通过依赖自动配置，不需要XL等配置文件。
Spring Cloud是一种云端分布式架构解决方案，基于spring boot，在spring boot做较少的配置，便可成为spring cloud中的一个微服务。
需要注意的是，我们不用spring cloud，单独使用spring boot没有任何问题，但是不使用spring boot是无法使用spring cloud的。
Spring boot 提供的思想是基于默认优先，它把我们一些常用的配置都内置了，从而大量减少了我们项目中的配置。而Spring Cloud是一套微服务治理框架，它包含了6大组成部分。
分别是：
Eureka：注册发现中心，用于把每个服务注册起来，让服务间互相认识。
Fegin：调用中心。通过一套注解实现服务间的互相调用。
Hystrix：熔断器。当某个微服务挂掉，熔断器可以保证调用链上的其他微服务正常使用。
gateway：微服务网关。可以解决微服务访问端口不固定，以及携带消息头的统一处理。
Cloud Config：云配置中心。真正的做到一个项目只有一套配置文件，把配置文件放到云端统一管理。而不是每个开发者自己电脑中独立一份，然后用版本控制工具维护。
Cloud Bus:I消息总线。当我们修改了配置文件之后，通过借助消息队列实现不停服务即可加载新的配置。

== 索引==

7.	避免索引失效
索引失效了。索引就没有意义了
哪些情况会导致索引失效
1.	索引列为NULL，索引失效 
只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。

2.	同一查询，多个索引，后面索引失效
mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

3.	like语句，可能引起索引失效
一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。


4.	NOT IN语句，索引失效
NOT IN操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替

5.	where条件中是OR关系，索引失效

6.	索引列进行运算，索引失效
select * from users where YEAR(adddate)



==项目==
sso单点登录的解决方案cas:serverTicket

fastDFS--tracker和storage组成

zookeeper全部挂掉了,注册中心全部宕掉,服务提供者和服务消费者扔能通过本地缓存通讯.

微服务之间相互调用，如果使用Feign调用，如果开启feign熔断，默认采用的是线程，feign调用和请求的线程不属于同一个线程，无法获取请求的线程数据,会造成空指针异常。

如何解决网站高并发问题
1.使用缓存，可以大量减少与数据库的交互，提高性能。
2.优化数据库查询语句
3.能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。
4.服务器集群解决单台的瓶颈问题
5.读写分离（双机热备功能。第一台数据库服务器，是对外提供增删改业务的生产服务器；第二台数据库服务器，主要进行读的操作.）


JSON.parseObject(spec, Map.class);





